# Supabase Docker Patterns

Local development configuration for Supabase stack, optimized for resource-constrained environments with minimal port exposure.

## Architecture Overview

```
Host Machine
│
├─ Exposed Ports (3)
│  ├─ :54321 → Kong (API Gateway)
│  │            └─ Routes to: auth, rest, realtime, storage, functions
│  ├─ :54323 → Studio (Web UI)
│  └─ :5173  → Vite (runs outside Docker)
│
└─ Docker Network (internal)
   ├─ db (PostgreSQL)        ← postgres-dev.conf tuning
   ├─ auth (GoTrue)
   ├─ rest (PostgREST)
   ├─ realtime
   ├─ storage
   ├─ functions (Edge Functions)
   ├─ imgproxy
   ├─ meta
   ├─ analytics
   ├─ inbucket (email testing)
   ├─ vector (logging)
   └─ logflare
```

---

## Pattern A: Port Consolidation

Reduces exposed ports from 28+ to 3 by overriding the base Supabase configuration. Only Kong (API gateway) and Studio (web UI) are exposed to the host, while all other services communicate via Docker's internal bridge network.

**When to use**: Always for local development to avoid port conflicts and simplify firewall rules.

> **Note:** This is an **override file** that extends the base Supabase Docker Compose configuration generated by `supabase start`. It cannot be used standalone—the Supabase CLI manages the base compose file.

### Override Structure

```yaml
# supabase/docker/docker-compose.override.yml
# NOTE: The `version` field is obsolete in Docker Compose v2+ and may show warnings.
# It's retained for compatibility but can be safely removed.
version: "3.8"

services:
  # --- EXPOSED SERVICES ---

  # Kong: API Gateway (primary entry point for your application)
  kong:
    ports:
      - "54321:8000" # REST API, GraphQL, Auth endpoints

  # Studio: Database management UI
  studio:
    ports:
      - "54323:3000" # Supabase Studio web interface

  # --- INTERNAL SERVICES (no host exposure) ---
  # By defining these services with empty ports lists, we override
  # the base docker-compose.yml and keep them internal to Docker network.

  db:
    ports: [] # PostgreSQL - accessed via Kong API

  auth:
    ports: [] # GoTrue auth service

  rest:
    ports: [] # PostgREST
  # ... repeat for all internal services
```

**Key points:**

- Empty `ports: []` overrides base docker-compose.yml to remove host exposure
- Kong acts as single entry point for all API requests
- Internal services communicate via Docker DNS (service names)
- To temporarily expose a service (e.g., inbucket), uncomment the relevant section

**Example:** `supabase/docker/docker-compose.override.yml`

---

## Pattern B: PostgreSQL Memory Tuning

Memory allocation strategy for 2GB containers following PostgreSQL best practices: shared_buffers at 25% of container memory, effective_cache_size as a query planner hint, and work_mem calculated to prevent OOM with multiple concurrent connections.

**When to use**: When running Supabase locally with container memory limits.

### Memory Formula

```conf
# supabase/docker/postgres-dev.conf

# Container: 2GB total

# Shared Buffers: 25% of container memory (industry standard)
# 2GB * 0.25 = 512MB - Used for caching frequently accessed data
shared_buffers = 512MB

# Effective Cache Size: Hint for query planner (doesn't allocate memory)
# 75% of container memory = 1.5GB - Helps optimize query plans
effective_cache_size = 1536MB

# Work Memory: Per-operation memory for sorts/hashes
# Conservative setting to prevent OOM with multiple connections
# Formula: (Total RAM - shared_buffers) / (max_connections * 4)
# (2048MB - 512MB) / (100 * 4) ≈ 4MB
work_mem = 4MB

# Maintenance Work Memory: For VACUUM, CREATE INDEX, ALTER TABLE
# 128MB is sufficient for development databases
maintenance_work_mem = 128MB

# Max Connections: 100 is plenty for development
# Each connection uses ~10MB, so 100 connections = ~1GB max
max_connections = 100
```

**Key points:**

- `shared_buffers` at 25% is PostgreSQL best practice
- `effective_cache_size` helps query planner but allocates nothing
- `work_mem` is per-operation, not per-connection - keep low to prevent OOM
- JIT disabled (`jit = off`) to save memory on simple queries

**Example:** `supabase/docker/postgres-dev.conf`

---

## Pattern C: Development Logging

Comprehensive logging configuration for debugging: slow query logging (>1s), connection tracking, lock wait logging, and statement logging for DDL/data-modifying operations.

**When to use**: Always enabled in local development for query analysis and debugging.

### Logging Configuration

```conf
# supabase/docker/postgres-dev.conf

# Log slow queries over 1 second
log_min_duration_statement = 1000

# Log connections and disconnections
log_connections = on
log_disconnections = on

# Log lock waits longer than 1 second
log_lock_waits = on
deadlock_timeout = 1s

# Log temporary file usage (helps identify queries needing more work_mem)
log_temp_files = 0

# Statement logging level
log_statement = 'mod'  # Log all DDL and data-modifying statements

# Enable timing in EXPLAIN ANALYZE
track_io_timing = on

# Track function call counts and time
track_functions = all
```

**Key points:**

- `log_min_duration_statement = 1000` catches queries over 1 second
- `log_temp_files = 0` logs ALL temp file usage (helps identify queries needing more work_mem)
- `log_statement = 'mod'` logs INSERT/UPDATE/DELETE but not SELECT (reduces noise)
- Check settings with: `SHOW log_min_duration_statement;`

**Example:** `supabase/docker/postgres-dev.conf`

---

## Pattern D: Service Isolation

Docker network isolation pattern where internal services (PostgreSQL, Auth, PostgREST, Realtime, Storage) have no host exposure and are accessed only through the Kong API gateway.

**When to use**: Standard pattern for Supabase local development security.

### Internal Service Access

```yaml
# supabase/docker/docker-compose.override.yml

# All internal services have ports removed
db:
  ports: [] # Access via Kong or docker exec

auth:
  ports: [] # Access via Kong at /auth/v1/

rest:
  ports: [] # Access via Kong at /rest/v1/

realtime:
  ports: [] # Access via Kong WebSocket

storage:
  ports: [] # Access via Kong at /storage/v1/

functions:
  ports: [] # Access via Kong at /functions/v1/

imgproxy:
  ports: [] # Image optimization

meta:
  ports: [] # Metadata service

analytics:
  ports: [] # Analytics service

inbucket:
  ports: [] # Email testing (uncomment to expose)

vector:
  ports: [] # Logging service

logflare:
  ports: [] # Log aggregation
```

**Key points:**

- All services accessible via Kong gateway at port 54321
- Use `docker exec` for direct database access when needed
- Service-to-service communication uses Docker DNS names
- To expose inbucket for email testing, uncomment its port mapping

**Example:** `supabase/docker/docker-compose.override.yml`

---

## Pattern Comparison Table

| Aspect          | Port Consolidation          | Memory Tuning              | Dev Logging       | Service Isolation           |
| --------------- | --------------------------- | -------------------------- | ----------------- | --------------------------- |
| **Purpose**     | Reduce host port exposure   | Optimize for 2GB container | Debug queries     | Security boundary           |
| **When to use** | Always                      | Always                     | Development only  | Always                      |
| **Key file**    | docker-compose.override.yml | postgres-dev.conf          | postgres-dev.conf | docker-compose.override.yml |
| **Complexity**  | Low                         | Medium                     | Low               | Low                         |

---

## Anti-Patterns to Avoid

### 1. Exposing All Ports

```yaml
# BAD: Exposes 28+ ports, creates conflicts and security risk
# (default Supabase docker-compose.yml behavior)
db:
  ports:
    - "54322:5432"
auth:
  ports:
    - "9999:9999"
# ... 20+ more services

# GOOD: Only expose what you need
db:
  ports: []  # Access through Kong gateway
```

### 2. Hardcoding Memory Without Container Limits

```conf
# BAD: Assumes unlimited memory
shared_buffers = 4GB
work_mem = 256MB

# GOOD: Calculate based on container limit (2GB)
shared_buffers = 512MB    # 25% of 2GB
work_mem = 4MB            # Prevents OOM
```

### 3. Disabling Development Logging

```conf
# BAD: No visibility into query performance
log_min_duration_statement = -1
log_statement = 'none'

# GOOD: Log slow queries and modifications
log_min_duration_statement = 1000
log_statement = 'mod'
```

### 4. Using Default Random Page Cost

```conf
# BAD: Assumes spinning disk (default = 4)
random_page_cost = 4

# GOOD: Optimize for SSD (Docker volumes use host SSD)
random_page_cost = 1.1
```

---

## Docker Configuration Checklist

When modifying Supabase Docker configuration:

1. [ ] Port changes go in `docker-compose.override.yml`, not base file
2. [ ] Verify port doesn't conflict: `lsof -i :PORT`
3. [ ] PostgreSQL changes go in `postgres-dev.conf`
4. [ ] Memory settings calculated for container limit
5. [ ] Restart containers after config changes: `supabase stop && supabase start`
6. [ ] Verify settings applied: `docker exec supabase_db_crispy-crm psql -U postgres -c "SHOW shared_buffers;"`

---

## File Reference

| Pattern                   | Primary Files                 |
| ------------------------- | ----------------------------- |
| **A: Port Consolidation** | `docker-compose.override.yml` |
| **B: Memory Tuning**      | `postgres-dev.conf`           |
| **C: Dev Logging**        | `postgres-dev.conf`           |
| **D: Service Isolation**  | `docker-compose.override.yml` |

---

## Quick Reference Commands

```bash
# Check exposed ports
docker compose ps --format "table {{.Name}}\t{{.Ports}}"

# Verify PostgreSQL memory settings
docker exec supabase_db_crispy-crm psql -U postgres -c "SHOW shared_buffers; SHOW work_mem; SHOW effective_cache_size;"

# View slow query log
docker logs supabase_db_crispy-crm 2>&1 | grep -i "duration"

# Direct database access (when port not exposed)
docker exec -it supabase_db_crispy-crm psql -U postgres

# Monitor container memory usage
docker stats supabase_db_crispy-crm --no-stream
```
