<GENERATED-CODE>
1.  **Update `src/atomic-crm/validation/contacts.ts`**: Add a new Zod schema specifically for validating imported contacts. This centralizes the rules.
2.  **Update `src/atomic-crm/contacts/useContactImport.tsx`**: Refactor the `processBatch` function to use the new Zod schema and aggregate all errors for each row. This is the core logic change.
3.  **Update `src/atomic-crm/contacts/ContactImportResult.tsx`**: Modify the UI to display a list of failed rows, with all associated error messages for each, and update the error download logic. This makes the UI much more informative.

Let's start with the validation schema.

<UPDATED_EXISTING_FILE: src/atomic-crm/validation/contacts.ts>
```typescript
import { z } from "zod";

/**
 * Contact validation schemas and functions
 * Implements validation rules from ContactInputs.tsx
 */

// Email and phone type enum
export const personalInfoTypeSchema = z.enum(["Work", "Home", "Other"]);

// LinkedIn URL validation
const LINKEDIN_URL_REGEX = /^http(?:s)?:\/\/(?:www\.)?linkedin\.com\//;
const isLinkedinUrl = z
  .string()
  .refine(
    (url) => {
      if (!url) return true;
      try {
        const parsedUrl = new URL(url);
        return parsedUrl.href.match(LINKEDIN_URL_REGEX) !== null;
      } catch {
        return false;
      }
    },
    { message: "URL must be from linkedin.com" },
  )
  .optional()
  .nullable();

// Email and phone sub-schemas for JSONB arrays
export const emailAndTypeSchema = z.object({
  email: z.string().email("Invalid email address"),
  type: personalInfoTypeSchema.default("Work"),
});

export const phoneNumberAndTypeSchema = z.object({
  number: z.string(),
  type: personalInfoTypeSchema.default("Work"),
});

// Note: Legacy schemas removed per Engineering Constitution #1 (NO BACKWARD COMPATIBILITY)
// phoneNumberSchema, emailSchema, contactStatusSchema - use emailAndTypeSchema and phoneNumberAndTypeSchema instead

// Contact-Organization relationship schema
export const contactOrganizationSchema = z
  .object({
    id: z.union([z.string(), z.number()]).optional(),
    contact_id: z.union([z.string(), z.number()]).optional(),
    organization_id: z.union([z.string(), z.number()]).optional(),
    is_primary: z.boolean().default(false),
    created_at: z.string().optional(),
    updated_at: z.string().optional(),
    deleted_at: z.string().optional().nullable(),
  })
  .refine((data) => {
    // Check for removed legacy fields and provide helpful error messages
    if ("is_primary_contact" in data) {
      throw new Error(
        "Field 'is_primary_contact' is no longer supported. Use is_primary in contact_organizations relationship instead.",
      );
    }
    return true;
  });

// Base contact schema - validates only fields that have UI inputs in ContactInputs.tsx
// Per "UI as source of truth" principle: we only validate what users can actually input
const contactBaseSchema = z.object({
  // Primary key
  id: z.union([z.string(), z.number()]).optional(),

  // Name fields - ContactIdentityInputs (required in UI)
  name: z.string().optional(), // Computed from first + last
  first_name: z.string().optional().nullable(),
  last_name: z.string().optional().nullable(),

  // Contact information - ContactPersonalInformationInputs
  // JSONB arrays in database: email and phone
  email: z.array(emailAndTypeSchema).default([]),
  phone: z.array(phoneNumberAndTypeSchema).default([]),

  // Professional information - ContactPositionInputs
  title: z.string().optional().nullable(),
  department: z.string().optional().nullable(),

  // Social media - ContactMiscInputs
  linkedin_url: isLinkedinUrl,

  // Relationships - ContactPositionInputs
  sales_id: z.union([z.string(), z.number()]).optional().nullable(),
  organization_id: z.union([z.string(), z.number()]).optional().nullable(),

  // System fields (readonly, not validated)
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
  created_by: z.union([z.string(), z.number()]).optional().nullable(),
  deleted_at: z.string().optional().nullable(),
  first_seen: z.string().optional(),
  last_seen: z.string().optional(),

  // Avatar field (managed by ImageEditorField, not validated)
  avatar: z.any().optional(), // Partial<RAFile>

  // Calculated/readonly fields (not user input)
  nb_tasks: z.number().optional(),
  company_name: z.string().optional().nullable(),
  search_tsv: z.any().optional(),

  // Notes field - text field for additional contact information
  notes: z.string().optional().nullable(),

  // Note: The following fields exist in database but are NOT validated
  // because they have no UI input fields in ContactInputs.tsx (per "UI as truth" principle):
  // - address, city, state, postal_code, country
  // - birthday, gender
  // - twitter_handle
  // - tags (array field handled separately)
});

// Helper function to transform data
function transformContactData(data: any) {
  // Compute name from first + last if not provided
  if (!data.name && (data.first_name || data.last_name)) {
    data.name = [data.first_name, data.last_name].filter(Boolean).join(' ') || 'Unknown';
  }

  // Ensure first_name and last_name are set if name is provided but they aren't
  if (data.name && !data.first_name && !data.last_name) {
    const parts = data.name.split(' ');
    if (parts.length >= 2) {
      data.first_name = parts[0];
      data.last_name = parts.slice(1).join(' ');
    } else {
      data.first_name = data.name;
      data.last_name = '';
    }
  }

  return data;
}

// Main contact schema with comprehensive validation
// This schema serves as the single source of truth for all contact validation
// per Engineering Constitution - all validation happens at API boundary only
export const contactSchema = contactBaseSchema
  .transform(transformContactData)
  .superRefine((data, ctx) => {
    // Validate that at least name or first_name/last_name is provided
    if (!data.name && !data.first_name && !data.last_name) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["name"],
        message: "Either name or first_name/last_name must be provided",
      });
    }

    // Contact-level email validation
    if (data.email && Array.isArray(data.email)) {
      const emailValidator = z.string().email("Invalid email address");
      data.email.forEach((entry: any, index: number) => {
        if (entry.email && !emailValidator.safeParse(entry.email).success) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ["email", index, "email"],
            message: "Must be a valid email address",
          });
        }
      });
    }
  });

// Schema specifically for CSV imports. It validates the raw string fields from the CSV.
export const importContactSchema = z
  .object({
    first_name: z.string().optional().nullable(),
    last_name: z.string().optional().nullable(),
    organization_name: z
      .string({ required_error: "Organization name is required" })
      .trim()
      .min(1, { message: "Organization name is required" }),
    email_work: z.string().trim().email("Invalid work email format").optional().or(z.literal("")),
    email_home: z.string().trim().email("Invalid home email format").optional().or(z.literal("")),
    email_other: z.string().trim().email("Invalid other email format").optional().or(z.literal("")),
    linkedin_url: z
      .string()
      .optional()
      .nullable()
      .refine(
        (url) => {
          if (!url) return true;
          try {
            const parsedUrl = new URL(url);
            return parsedUrl.href.match(LINKEDIN_URL_REGEX) !== null;
          } catch {
            return false;
          }
        },
        { message: "LinkedIn URL must be a valid URL from linkedin.com" },
      ),
  })
  .superRefine((data, ctx) => {
    if (!data.first_name?.trim() && !data.last_name?.trim()) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["first_name"],
        message: "Either first name or last name must be provided",
      });
    }
  });

// Type inference
export type ContactInput = z.input<typeof contactSchema>;
export type Contact = z.infer<typeof contactSchema>;
export type ContactOrganization = z.infer<typeof contactOrganizationSchema>;

// Validation function matching expected signature from unifiedDataProvider
// This is the ONLY place where contact validation occurs
export async function validateContactForm(data: any): Promise<void> {
  try {
    // Ensure at least one email is provided if email exists
    if (data.email && Array.isArray(data.email) && data.email.length > 0) {
      // Validate each email entry
      data.email.forEach((entry: any, index: number) => {
        if (!entry.email || entry.email.trim() === "") {
          throw new z.ZodError([
            {
              code: z.ZodIssueCode.custom,
              message: "Email address is required",
              path: ["email", index, "email"],
            },
          ]);
        }
      });
    }

    // Parse and validate the data
    contactSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Format validation errors for React Admin
      const formattedErrors: Record<string, string> = {};
      error.issues.forEach((err) => {
        const path = err.path.join(".");
        formattedErrors[path] = err.message;
      });

      // Throw error in React Admin expected format
      throw {
        message: "Validation failed",
        errors: formattedErrors,
      };
    }
    throw error;
  }
}

// Create-specific schema (stricter requirements)
export const createContactSchema = contactBaseSchema
  .omit({
    id: true,
    first_seen: true,
    last_seen: true,
    deleted_at: true,
    nb_tasks: true,
    company_name: true,
    created_at: true,
    updated_at: true,
    created_by: true,
    search_tsv: true,
  })
  .transform(transformContactData)
  .superRefine((data, ctx) => {
    // For creation, we need at least first_name and last_name OR name
    if (!data.name && (!data.first_name || !data.last_name)) {
      if (!data.first_name) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ["first_name"],
          message: "First name is required",
        });
      }
      if (!data.last_name) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ["last_name"],
          message: "Last name is required",
        });
      }
    }

    // Sales ID is required for creation
    if (!data.sales_id) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["sales_id"],
        message: "Account manager is required",
      });
    }
  });

// Update-specific schema (more flexible)
// ID is passed in params.id by React Admin, not in data
export const updateContactSchema = contactBaseSchema
  .partial()
  .transform(transformContactData);

// Export validation functions for specific operations
export async function validateCreateContact(data: any): Promise<void> {
  try {
    // Ensure at least one email is provided for new contacts
    if (!data.email || !Array.isArray(data.email) || data.email.length === 0) {
      throw new z.ZodError([
        {
          code: z.ZodIssueCode.custom,
          message: "At least one email address is required",
          path: ["email"],
        },
      ]);
    }

    createContactSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const formattedErrors: Record<string, string> = {};
      error.issues.forEach((err) => {
        const path = err.path.join(".");
        formattedErrors[path] = err.message;
      });
      throw {
        message: "Validation failed",
        errors: formattedErrors,
      };
    }
    throw error;
  }
}

export async function validateUpdateContact(data: any): Promise<void> {
  try {
    updateContactSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const formattedErrors: Record<string, string> = {};
      error.issues.forEach((err) => {
        const path = err.path.join(".");
        formattedErrors[path] = err.message;
      });
      throw {
        message: "Validation failed",
        errors: formattedErrors,
      };
    }
    throw error;
  }
}

// Validation for contact-organization relationships
export async function validateContactOrganization(data: any): Promise<void> {
  try {
    contactOrganizationSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const formattedErrors: Record<string, string> = {};
      error.issues.forEach((err) => {
        const path = err.path.join(".");
        formattedErrors[path] = err.message;
      });
      throw {
        message: "Validation failed",
        errors: formattedErrors,
      };
    }
    throw error;
  }
}
```
</UPDATED_EXISTING_FILE>

Next, we'll refactor the import hook to use this schema and collect all errors.

<UPDATED_EXISTING_FILE: src/atomic-crm/contacts/useContactImport.tsx>
```typescript
import type { DataProvider } from "ra-core";
import { useDataProvider, useGetIdentity } from "ra-core";
import { useCallback, useMemo } from "react";
import type { Organization, Tag } from "../types";
import { mapHeadersToFields, isFullNameColumn, findCanonicalField } from "./columnAliases";
import { importContactSchema } from "../validation/contacts";
import { ZodError } from "zod";

export interface ContactImportSchema {
  first_name: string;
  last_name: string;
  gender?: string;
  title?: string;
  organization_name: string; // Primary organization (mandatory)
  email_work?: string;
  email_home?: string;
  email_other?: string;
  phone_work?: string;
  phone_home?: string;
  phone_other?: string;
  first_seen?: string;
  last_seen?: string;
  tags?: string;
  linkedin_url?: string;
  notes?: string; // Contact notes text field
}

export interface FieldError {
  field: string;
  message: string;
  value?: any;
}

export interface ImportError {
  row: number;
  data: any;
  errors: FieldError[];
}

export interface ImportResult {
  totalProcessed: number;
  successCount: number;
  skippedCount: number;
  failedCount: number;
  errors: ImportError[];
  duration: number;
  startTime: Date;
  endTime: Date;
}

export interface ImportOptions {
  preview?: boolean; // If true, validate only without database writes
  onProgress?: (current: number, total: number) => void; // Progress callback
}

export function useContactImport() {
  const today = new Date().toISOString();
  const { identity } = useGetIdentity();
  const dataProvider = useDataProvider();

  // organization cache to avoid creating the same organization multiple times and costly roundtrips
  // Cache is dependent of dataProvider, so it's safe to use it as a dependency
  const organizationsCache = useMemo(
    () => new Map<string, Organization>(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dataProvider],
  );
  const getOrganizations = useCallback(
    async (names: string[], preview = false) =>
      preview
        ? validateOrganizationNames(names)
        : fetchRecordsWithCache<Organization>(
            "organizations",
            organizationsCache,
            names,
            (name) => ({
              name,
              created_at: new Date().toISOString(),
              sales_id: identity?.id,
            }),
            dataProvider,
          ),
    [organizationsCache, identity?.id, dataProvider],
  );

  // Tags cache to avoid creating the same tag multiple times and costly roundtrips
  // Cache is dependent of dataProvider, so it's safe to use it as a dependency
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const tagsCache = useMemo(() => new Map<string, Tag>(), [dataProvider]);
  const getTags = useCallback(
    async (names: string[], preview = false) =>
      preview
        ? validateTagNames(names)
        : fetchRecordsWithCache<Tag>(
            "tags",
            tagsCache,
            names,
            (name) => ({
              name,
              color: "gray",
            }),
            dataProvider,
          ),
    [tagsCache, dataProvider],
  );

  const processBatch = useCallback(
    async (batch: ContactImportSchema[], options: ImportOptions = {}): Promise<ImportResult> => {
      const { preview = false, onProgress } = options;
      console.log("processBatch called with:", { batchSize: batch.length, preview, options });
      const startTime = new Date();
      const errors: ImportError[] = [];
      let successCount = 0;
      let skippedCount = 0;
      let failedCount = 0;
      const totalProcessed = batch.length;
      // Report progress if callback provided
      if (onProgress) {
        onProgress(0, totalProcessed);
      }

      const [organizations, tags] = await Promise.all([
        getOrganizations(
          batch
            .map((contact) => contact.organization_name?.trim())
            .filter((name) => name),
          preview,
        ),
        getTags(batch.flatMap((batch) => parseTags(batch.tags)), preview),
      ]);

      // Process all contacts with Promise.allSettled for better error tracking
      const results = await Promise.allSettled(
        batch.map(async (contactData, index) => {
          const rowNumber = index + 1;
          const rowErrors: FieldError[] = [];

          // 1. Validate with Zod schema first to catch all format/presence errors
          const validationResult = importContactSchema.safeParse(contactData);
          if (!validationResult.success) {
            validationResult.error.issues.forEach((issue) => {
              rowErrors.push({
                field: issue.path.join("."),
                message: issue.message,
                value: issue.path.reduce((obj, key) => obj?.[key], contactData),
              });
            });
          }

          const {
            first_name,
            last_name,
            gender,
            title,
            email_work,
            email_home,
            email_other,
            phone_work,
            phone_home,
            phone_other,
            first_seen,
            last_seen,
            organization_name,
            tags: tagNames,
            linkedin_url,
            notes,
          } = contactData;

          // 2. Perform logic-based validation (e.g., organization existence)
          const trimmedOrgName = organization_name?.trim();
          if (trimmedOrgName) {
            if (preview) {
              if (!organizations.has(trimmedOrgName)) {
                rowErrors.push({
                  field: "organization_name",
                  message: `Organization "${trimmedOrgName}" would need to be created`,
                  value: trimmedOrgName,
                });
              }
            } else {
              const organization = organizations.get(trimmedOrgName);
              if (!organization?.id) {
                rowErrors.push({
                  field: "organization_name",
                  message: `Failed to find or create organization "${trimmedOrgName}"`,
                  value: trimmedOrgName,
                });
              }
            }
          }

          // 3. If any errors were found, bail early and report them
          if (rowErrors.length > 0) {
            return {
              rowNumber,
              success: false,
              errors: rowErrors,
              data: contactData,
            };
          }

          // 4. If all validations pass, proceed with creating the payload
          try {
            const email = [
              { email: email_work, type: "Work" },
              { email: email_home, type: "Home" },
              { email: email_other, type: "Other" },
            ].filter(({ email }) => email);

            const phone = [
              { number: phone_work, type: "Work" },
              { number: phone_home, type: "Home" },
              { number: phone_other, type: "Other" },
            ].filter(({ number }) => number);

            const tagList = parseTags(tagNames)
              .map((name) => tags.get(name))
              .filter((tag): tag is Tag => !!tag);

            const organization = organizations.get(trimmedOrgName);

            const contactPayload = {
              first_name,
              last_name,
              gender,
              title,
              email,
              phone,
              first_seen: first_seen ? new Date(first_seen).toISOString() : today,
              last_seen: last_seen ? new Date(last_seen).toISOString() : today,
              tags: preview ? [] : tagList.map((tag) => tag.id),
              sales_id: identity?.id,
              linkedin_url,
              notes,
              organization_id: organization?.id,
            };

            if (preview) {
              await dataProvider.create("contacts", {
                data: contactPayload,
                meta: { dryRun: true },
              });
            } else {
              await dataProvider.create("contacts", {
                data: contactPayload,
              });
            }

            return { rowNumber, success: true };
          } catch (error: any) {
            // 5. Catch errors from the dataProvider (e.g., unique constraints)
            const finalErrors: FieldError[] = [];
            if (error instanceof ZodError) {
              error.issues.forEach((issue) => {
                finalErrors.push({
                  field: issue.path.join("."),
                  message: issue.message,
                });
              });
            } else if (error.body?.errors) {
              // Handle structured React Admin validation errors
              for (const [field, message] of Object.entries(error.body.errors)) {
                finalErrors.push({ field, message: String(message) });
              }
            } else {
              finalErrors.push({
                field: "general",
                message: error.message || "An unknown error occurred during record creation.",
              });
            }
            return {
              rowNumber,
              success: false,
              errors: finalErrors,
              data: contactData,
            };
          } finally {
            if (onProgress) {
              onProgress(index + 1, totalProcessed);
            }
          }
        }),
      );

      // Process results and categorize them
      results.forEach((result, index) => {
        if (result.status === "fulfilled") {
          const value = result.value as any;
          if (value.success) {
            successCount++;
          } else {
            failedCount++;
            errors.push({
              row: value.rowNumber,
              data: value.data,
              errors: value.errors,
            });
          }
        } else {
          // Promise rejected (catastrophic failure for this row)
          failedCount++;
          errors.push({
            row: index + 1,
            data: batch[index],
            errors: [
              {
                field: "processing",
                message: result.reason?.message || result.reason || "Unknown processing error",
              },
            ],
          });
        }
      });

      const endTime = new Date();

      const result = {
        totalProcessed,
        successCount,
        skippedCount,
        failedCount,
        errors,
        duration: endTime.getTime() - startTime.getTime(),
        startTime,
        endTime,
      };

      console.log("processBatch returning:", result);
      return result;
    },
    [dataProvider, getOrganizations, getTags, identity?.id, today],
  );

  return processBatch;
}

const fetchRecordsWithCache = async function <T>(
  resource: string,
  cache: Map<string, T>,
  names: string[],
  getCreateData: (name: string) => Partial<T>,
  dataProvider: DataProvider,
) {
  const trimmedNames = [...new Set(names.map((name) => name.trim()))];
  const uncachedRecordNames = trimmedNames.filter((name) => !cache.has(name));

  // check the backend for existing records
  if (uncachedRecordNames.length > 0) {
    const response = await dataProvider.getList(resource, {
      filter: {
        "name@in": `(${uncachedRecordNames
          .map((name) => `"${name}"`)
          .join(",")})`,
      },
      pagination: { page: 1, perPage: trimmedNames.length },
      sort: { field: "id", order: "ASC" },
    });
    for (const record of response.data) {
      cache.set(record.name.trim(), record);
    }
  }

  // create missing records in parallel
  await Promise.all(
    uncachedRecordNames.map(async (name) => {
      if (cache.has(name)) return;
      const response = await dataProvider.create(resource, {
        data: getCreateData(name),
      });
      cache.set(name, response.data);
    }),
  );

  // now all records are in cache, return a map of all records
  return trimmedNames.reduce((acc, name) => {
    acc.set(name, cache.get(name) as T);
    return acc;
  }, new Map<string, T>());
};

const parseTags = (tags: string) =>
  tags
    ?.split(",")
    ?.map((tag: string) => tag.trim())
    ?.filter((tag: string) => tag) ?? [];

/**
 * Validate organization names for preview mode
 * Returns a Map similar to fetchRecordsWithCache but without database operations
 */
const validateOrganizationNames = async (names: string[]): Promise<Map<string, Organization>> => {
  const trimmedNames = [...new Set(names.map((name) => name.trim()))];
  const result = new Map<string, Organization>();

  // In preview mode, we just create placeholder organizations
  // to indicate they would be created during actual import
  for (const name of trimmedNames) {
    result.set(name, {
      id: `preview-org-${name}`,
      name,
      created_at: new Date().toISOString(),
    } as Organization);
  }

  return result;
};

/**
 * Validate tag names for preview mode
 * Returns a Map similar to fetchRecordsWithCache but without database operations
 */
const validateTagNames = async (names: string[]): Promise<Map<string, Tag>> => {
  const trimmedNames = [...new Set(names.map((name) => name.trim()))];
  const result = new Map<string, Tag>();

  // In preview mode, we just create placeholder tags
  // to indicate they would be created during actual import
  for (const name of trimmedNames) {
    result.set(name, {
      id: `preview-tag-${name}`,
      name,
      color: "gray",
    } as Tag);
  }

  return result;
};
```
</UPDATED_EXISTING_FILE>

Finally, let's update the result component to display these detailed, multi-error reports.

<UPDATED_EXISTING_FILE: src/atomic-crm/contacts/ContactImportResult.tsx>
```typescript
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertCircle,
  AlertTriangle,
  CheckCircle2,
  Clock,
  Download,
  FileText,
  RefreshCw,
  X,
} from "lucide-react";
import * as React from "react";

export interface FieldError {
  field: string;
  message: string;
  value?: any;
}

export interface ImportError {
  row: number;
  data: Record<string, unknown>;
  errors: FieldError[];
}

export interface ImportResultData {
  totalProcessed: number;
  successCount: number;
  skippedCount: number;
  failedCount: number;
  errors: ImportError[];
  duration: number; // in milliseconds
  startTime?: Date;
  endTime?: Date;
}

interface ContactImportResultProps {
  open: boolean;
  onClose: () => void;
  onRetry?: () => void;
  result: ImportResultData;
  allowRetry?: boolean;
}

export function ContactImportResult({
  open,
  onClose,
  onRetry,
  result,
  allowRetry = false,
}: ContactImportResultProps) {
  const successRate = result.totalProcessed > 0
    ? Math.round((result.successCount / result.totalProcessed) * 100)
    : 0;

  const hasErrors = result.failedCount > 0 || result.skippedCount > 0;
  const isComplete = result.successCount === result.totalProcessed;

  // Format duration in human-readable format
  const formatDuration = (ms: number) => {
    const seconds = Math.floor((ms / 1000) % 60);
    const minutes = Math.floor((ms / (60 * 1000)) % 60);
    const hours = Math.floor(ms / (60 * 60 * 1000));

    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    }
    if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    }
    return `${seconds}s`;
  };

  const handleDownloadErrors = () => {
    // Create CSV content with comprehensive error details
    const csvContent = [
      [
        "Row",
        "Error Reasons",
        "First Name",
        "Last Name",
        "Organization",
        "Title",
        "Email (Work)",
        "Email (Home)",
        "Email (Other)",
        "Phone (Work)",
        "Phone (Home)",
        "Phone (Other)",
        "LinkedIn URL",
        "Notes",
      ],
      ...result.errors.map((error) => [
        error.row.toString(),
        error.errors.map((e) => `${e.field}: ${e.message}`).join("; "), // Join all error messages
        error.data.first_name || "",
        error.data.last_name || "",
        error.data.organization_name || "",
        error.data.title || "",
        error.data.email_work || "",
        error.data.email_home || "",
        error.data.email_other || "",
        error.data.phone_work || "",
        error.data.phone_home || "",
        error.data.phone_other || "",
        error.data.linkedin_url || "",
        error.data.notes || "",
      ]),
    ]
      .map((row) => row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(","))
      .join("\n");

    // Create and trigger download
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", `import_errors_${new Date().toISOString().split("T")[0]}.csv`);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            {isComplete ? (
              <>
                <CheckCircle2 className="h-5 w-5 text-green-600" />
                Import Completed Successfully
              </>
            ) : hasErrors ? (
              <>
                <AlertTriangle className="h-5 w-5 text-yellow-600" />
                Import Completed with Issues
              </>
            ) : (
              <>
                <CheckCircle2 className="h-5 w-5 text-green-600" />
                Import Completed
              </>
            )}
          </DialogTitle>
          <DialogDescription>
            Processed {result.totalProcessed.toLocaleString()} contacts in{" "}
            {formatDuration(result.duration)}
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto space-y-4 py-4">
          {/* Summary Statistics */}
          <div className="grid grid-cols-3 gap-4">
            <div className="border rounded-lg p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">Successful</p>
                  <p className="text-2xl font-semibold text-green-600">
                    {result.successCount.toLocaleString()}
                  </p>
                </div>
                <CheckCircle2 className="h-8 w-8 text-green-600 opacity-20" />
              </div>
            </div>

            <div className="border rounded-lg p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">Skipped</p>
                  <p className="text-2xl font-semibold text-yellow-600">
                    {result.skippedCount.toLocaleString()}
                  </p>
                </div>
                <AlertTriangle className="h-8 w-8 text-yellow-600 opacity-20" />
              </div>
            </div>

            <div className="border rounded-lg p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">Failed</p>
                  <p className="text-2xl font-semibold text-red-600">
                    {result.failedCount.toLocaleString()}
                  </p>
                </div>
                <X className="h-8 w-8 text-red-600 opacity-20" />
              </div>
            </div>
          </div>

          {/* Success Rate Progress */}
          <div className="space-y-2">
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium">Success Rate</span>
              <span className="text-sm text-muted-foreground">{successRate}%</span>
            </div>
            <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
              <div
                className={`h-full transition-all ${
                  successRate >= 90
                    ? "bg-green-600"
                    : successRate >= 70
                    ? "bg-yellow-600"
                    : "bg-red-600"
                }`}
                style={{ width: `${successRate}%` }}
              />
            </div>
          </div>

          {/* Performance Metrics */}
          <div className="border rounded-lg p-4 space-y-2">
            <h3 className="font-medium flex items-center gap-2">
              <Clock className="h-4 w-4" />
              Performance Metrics
            </h3>
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div>
                <span className="text-muted-foreground">Total Duration:</span>{" "}
                <span className="font-medium">{formatDuration(result.duration)}</span>
              </div>
              <div>
                <span className="text-muted-foreground">Processing Speed:</span>{" "}
                <span className="font-medium">
                  {result.duration > 0
                    ? `${Math.round((result.totalProcessed / result.duration) * 1000)} contacts/sec`
                    : "N/A"}
                </span>
              </div>
              {result.startTime && (
                <div>
                  <span className="text-muted-foreground">Started at:</span>{" "}
                  <span className="font-medium">
                    {new Date(result.startTime).toLocaleTimeString()}
                  </span>
                </div>
              )}
              {result.endTime && (
                <div>
                  <span className="text-muted-foreground">Completed at:</span>{" "}
                  <span className="font-medium">
                    {new Date(result.endTime).toLocaleTimeString()}
                  </span>
                </div>
              )}
            </div>
          </div>

          {/* Error Details */}
          {hasErrors && result.errors.length > 0 && (
            <div className="border rounded-lg p-4 space-y-3">
              <div className="flex items-center justify-between">
                <h3 className="font-medium flex items-center gap-2">
                  <AlertCircle className="h-4 w-4" />
                  Rejected Records ({result.errors.length})
                </h3>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleDownloadErrors}
                    className="gap-2"
                  >
                    <Download className="h-3 w-3" />
                    Export
                  </Button>
                </div>
              </div>

              <div className="space-y-2 max-h-96 overflow-y-auto p-1">
                {result.errors.map((error) => (
                  <div
                    key={error.row}
                    className="flex flex-col gap-2 p-3 bg-muted/40 rounded border border-red-200"
                  >
                    <div className="flex items-center gap-2">
                      <Badge variant="outline" className="text-xs">
                        Row {error.row}
                      </Badge>
                      <span className="font-medium text-sm">
                        {error.data.first_name || "(no first name)"}{" "}
                        {error.data.last_name || "(no last name)"}
                      </span>
                    </div>
                    <ul className="text-xs text-red-700 space-y-1 ml-4 list-disc list-inside">
                      {error.errors.map((fieldError, index) => (
                        <li key={index}>
                          <span className="font-semibold capitalize">
                            {fieldError.field.replace(/_/g, " ")}:
                          </span>{" "}
                          {fieldError.message}
                          {fieldError.value && (
                            <span className="text-muted-foreground italic ml-1">
                              (was: "{String(fieldError.value)}")
                            </span>
                          )}
                        </li>
                      ))}
                    </ul>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Warnings for skipped rows */}
          {result.skippedCount > 0 && (
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>Skipped Rows</AlertTitle>
              <AlertDescription>
                {result.skippedCount} {result.skippedCount === 1 ? "row was" : "rows were"}{" "}
                skipped during import. These typically include rows with missing required
                fields like organization name. Review the error details above for specific
                reasons.
              </AlertDescription>
            </Alert>
          )}
        </div>

        <DialogFooter>
          <div className="flex gap-2 w-full justify-between">
            <div className="flex gap-2">
              {hasErrors && result.errors.length > 0 && (
                <Button
                  variant="outline"
                  onClick={handleDownloadErrors}
                  className="gap-2"
                >
                  <FileText className="h-4 w-4" />
                  Download Error Report
                </Button>
              )}
            </div>
            <div className="flex gap-2">
              {allowRetry && hasErrors && (
                <Button
                  variant="outline"
                  onClick={() => {
                    onRetry?.();
                    onClose();
                  }}
                  className="gap-2"
                >
                  <RefreshCw className="h-4 w-4" />
                  Retry Failed
                </Button>
              )}
              <Button onClick={onClose} variant={isComplete ? "default" : "outline"}>
                {isComplete ? "Done" : "Close"}
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```
</UPDATED_EXISTING_FILE>
</GENERATED-CODE>
