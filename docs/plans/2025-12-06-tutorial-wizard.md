# First-Time Tutorial Wizard - Implementation Plan

> **For Executing Agent:**
> 1. **FIRST:** Read `CLAUDE.md` in project root for engineering principles
> 2. **THEN:** Follow tasks exactly. Do not improvise. Zero context assumed.
> 3. **ANNOUNCE:** Before each task, state "Starting Task N: [name]"

**Goal:** A 5-step modal wizard that guides new users through creating their first real records (Organization → Contact → Opportunity → Activity → Task), showing on every login until "Don't show again" is checked, with database-persisted progress for resume capability.

**Architecture:** TutorialProvider context wraps Layout.tsx, manages wizard state via useTutorialProgress hook that queries/updates tutorial_progress table. TutorialWizard modal renders step forms with progressive disclosure (minimal fields + "Show more" expansion). Declarative wizardConfig.ts defines step order for maintainability.

**Task Granularity:** standard (5-15 min per task)

**Parallelization:**
- **Group A:** Tasks 1-3 (Foundation) - sequential within group
- **Group B:** Tasks 4-7 (Core Components) - sequential, after Group A
- **Group C:** Tasks 8-10 (UI Components) - parallel within group, after Task 6
- **Group D:** Tasks 11-15 (Step Forms) - parallel within group, after Task 9
- **Group E:** Tasks 16-18 (Integration) - sequential, after Groups C+D
- **Group F:** Tasks 19-20 (Testing) - parallel, after Group E

**Constitution Principles In Play:**
- [x] Error handling (fail fast - NO retry logic)
- [x] Validation (Zod at API boundary only)
- [x] Form state (derived from schema)
- [x] Data access (unified provider only)
- [x] Types (`interface` for objects, `type` for unions)

---

## Task Dependencies

| Task | Name | Depends On | Can Parallelize With |
|------|------|------------|---------------------|
| 1 | Database migration | None | None |
| 2 | Zod validation schema | 1 | None |
| 3 | Data provider resource | 2 | None |
| 4 | useTutorialProgress hook | 3 | None |
| 5 | Wizard configuration | 4 | None |
| 6 | TutorialProvider context | 5 | None |
| 7 | TutorialWizard modal | 6 | None |
| 8 | TutorialStepIndicator | 6 | 9, 10 |
| 9 | TutorialStepContent | 6 | 8, 10 |
| 10 | TutorialDismissCheckbox | 6 | 8, 9 |
| 11 | OrganizationStep | 9 | 12, 13, 14, 15 |
| 12 | ContactStep | 9 | 11, 13, 14, 15 |
| 13 | OpportunityStep | 9 | 11, 12, 14, 15 |
| 14 | ActivityStep | 9 | 11, 12, 13, 15 |
| 15 | TaskStep | 9 | 11, 12, 13, 14 |
| 16 | TutorialSuccessMessage | 11-15 | None |
| 17 | Module index.tsx | 16 | None |
| 18 | Layout.tsx integration | 17 | None |
| 19 | Unit tests | 18 | 20 |
| 20 | E2E test | 18 | 19 |

---

## Phase 1: Foundation

### Task 1: Database Migration

**Depends on:** None - can start immediately

**Constitution Check:**
- [x] No retry logic / circuit breakers
- [x] RLS policies for security
- [x] Proper foreign key constraints

**Files:**
- Create: `supabase/migrations/20251206000001_create_tutorial_progress.sql`

**Step 1: Create the migration file**

```sql
-- supabase/migrations/20251206000001_create_tutorial_progress.sql

-- Tutorial progress tracking for first-time user wizard
CREATE TABLE public.tutorial_progress (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sales_id bigint NOT NULL REFERENCES public.sales(id) ON DELETE CASCADE,

  -- Step completion tracking (order: org → contact → opp → activity → task)
  organization_completed boolean NOT NULL DEFAULT false,
  contact_completed boolean NOT NULL DEFAULT false,
  opportunity_completed boolean NOT NULL DEFAULT false,
  activity_completed boolean NOT NULL DEFAULT false,
  task_completed boolean NOT NULL DEFAULT false,

  -- IDs of created records (for linking between steps)
  created_organization_id bigint REFERENCES public.organizations(id) ON DELETE SET NULL,
  created_contact_id bigint REFERENCES public.contacts(id) ON DELETE SET NULL,
  created_opportunity_id bigint REFERENCES public.opportunities(id) ON DELETE SET NULL,
  created_activity_id bigint REFERENCES public.activities(id) ON DELETE SET NULL,
  created_task_id bigint REFERENCES public.tasks(id) ON DELETE SET NULL,

  -- Dismissal tracking
  dismissed boolean NOT NULL DEFAULT false,
  dismissed_at timestamp with time zone,

  -- Timestamps
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),

  -- One progress record per user
  CONSTRAINT unique_sales_tutorial UNIQUE (sales_id)
);

-- Enable RLS
ALTER TABLE public.tutorial_progress ENABLE ROW LEVEL SECURITY;

-- RLS policies: users can only access their own tutorial progress
CREATE POLICY "Users can view own tutorial progress"
  ON public.tutorial_progress FOR SELECT
  USING (sales_id = public.get_current_sales_id());

CREATE POLICY "Users can insert own tutorial progress"
  ON public.tutorial_progress FOR INSERT
  WITH CHECK (sales_id = public.get_current_sales_id());

CREATE POLICY "Users can update own tutorial progress"
  ON public.tutorial_progress FOR UPDATE
  USING (sales_id = public.get_current_sales_id())
  WITH CHECK (sales_id = public.get_current_sales_id());

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON public.tutorial_progress TO authenticated;
GRANT USAGE ON SEQUENCE public.tutorial_progress_id_seq TO authenticated;

-- Add comment for documentation
COMMENT ON TABLE public.tutorial_progress IS 'Tracks first-time tutorial wizard progress per user';
```

**Step 2: Apply migration locally**

```bash
npx supabase db reset
```

**Expected output:** Migration applies successfully, table created.

**Step 3: Verify table exists**

```bash
npx supabase db dump --local | grep tutorial_progress
```

**Expected output:** Shows `CREATE TABLE public.tutorial_progress`

---

### Task 2: Zod Validation Schema

**Depends on:** Task 1

**Constitution Check:**
- [x] Using `z.strictObject()` for mass assignment prevention
- [x] All strings have `.max()` constraint
- [x] Using `z.coerce` for non-string inputs
- [x] `interface` for object shapes, `type` for unions

**Files:**
- Create: `src/atomic-crm/tutorial/validation/tutorial.ts`

**Step 1: Create validation directory**

```bash
mkdir -p src/atomic-crm/tutorial/validation
```

**Step 2: Write the schema**

```typescript
// src/atomic-crm/tutorial/validation/tutorial.ts
import { z } from "zod";

/**
 * Tutorial step identifiers - order matters for progression
 * Using type (not interface) because this is a union
 */
export type TutorialStepId =
  | 'organization'
  | 'contact'
  | 'opportunity'
  | 'activity'
  | 'task';

/**
 * Wizard status for UI state management
 * Using type for union
 */
export type WizardStatus = 'loading' | 'show' | 'hide' | 'complete';

/**
 * Tutorial progress record from database
 * Using interface for object shape (Constitution compliance)
 */
export interface TutorialProgress {
  id?: number;
  sales_id: number;
  organization_completed: boolean;
  contact_completed: boolean;
  opportunity_completed: boolean;
  activity_completed: boolean;
  task_completed: boolean;
  created_organization_id?: number | null;
  created_contact_id?: number | null;
  created_opportunity_id?: number | null;
  created_activity_id?: number | null;
  created_task_id?: number | null;
  dismissed: boolean;
  dismissed_at?: string | null;
  created_at?: string;
  updated_at?: string;
}

/**
 * Zod schema for API boundary validation
 * Uses strictObject for mass assignment prevention
 */
export const tutorialProgressSchema = z.strictObject({
  id: z.union([z.string(), z.number()]).optional(),
  sales_id: z.union([z.string(), z.number()]),

  // Step completion - coerce for form inputs
  organization_completed: z.coerce.boolean().default(false),
  contact_completed: z.coerce.boolean().default(false),
  opportunity_completed: z.coerce.boolean().default(false),
  activity_completed: z.coerce.boolean().default(false),
  task_completed: z.coerce.boolean().default(false),

  // Created record IDs
  created_organization_id: z.union([z.string(), z.number()]).optional().nullable(),
  created_contact_id: z.union([z.string(), z.number()]).optional().nullable(),
  created_opportunity_id: z.union([z.string(), z.number()]).optional().nullable(),
  created_activity_id: z.union([z.string(), z.number()]).optional().nullable(),
  created_task_id: z.union([z.string(), z.number()]).optional().nullable(),

  // Dismissal
  dismissed: z.coerce.boolean().default(false),
  dismissed_at: z.string().max(50).optional().nullable(),

  // Timestamps
  created_at: z.string().max(50).optional(),
  updated_at: z.string().max(50).optional(),
});

/**
 * Schema for creating new progress record
 */
export const createTutorialProgressSchema = tutorialProgressSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});

/**
 * Schema for updating progress
 */
export const updateTutorialProgressSchema = tutorialProgressSchema.partial();

/**
 * Get default values from schema (Constitution: form defaults from schema)
 */
export const getTutorialProgressDefaults = () =>
  tutorialProgressSchema.partial().parse({});
```

**Step 3: Verify TypeScript compiles**

```bash
npx tsc --noEmit src/atomic-crm/tutorial/validation/tutorial.ts
```

**Expected output:** No errors

---

### Task 3: Data Provider Resource

**Depends on:** Task 2

**Constitution Check:**
- [x] Using unified data provider only
- [x] Validation at API boundary
- [x] No direct Supabase imports

**Files:**
- Modify: `src/atomic-crm/providers/supabase/unifiedDataProvider.ts`

**Step 1: Add tutorial_progress to validated resources**

Find the `resourceUsesValidation` function and add `'tutorial_progress'` to the array.

```typescript
// In unifiedDataProvider.ts, find resourceUsesValidation and add:
const validatedResources = [
  'contacts',
  'organizations',
  'opportunities',
  'activities',
  'tasks',
  'tutorial_progress', // ✅ ADD THIS
];
```

**Step 2: Add validation service entry**

Find the `validationService` object and add:

```typescript
// Add to validationService object:
tutorial_progress: {
  create: (data: unknown) => tutorialProgressSchema.parse(data),
  update: (data: unknown) => tutorialProgressSchema.partial().parse(data),
},
```

**Step 3: Add import at top of file**

```typescript
import { tutorialProgressSchema } from '../../tutorial/validation/tutorial';
```

**Step 4: Verify no TypeScript errors**

```bash
npx tsc --noEmit
```

---

## Phase 2: Core Components

### Task 4: useTutorialProgress Hook

**Depends on:** Task 3

**Constitution Check:**
- [x] Using unified data provider (useDataProvider)
- [x] No retry logic - let errors throw
- [x] Form defaults from schema

**Files:**
- Create: `src/atomic-crm/tutorial/useTutorialProgress.ts`
- Test: `src/atomic-crm/tutorial/__tests__/useTutorialProgress.test.ts`

**Step 1: Write failing test**

```typescript
// src/atomic-crm/tutorial/__tests__/useTutorialProgress.test.ts
import { describe, it, expect, vi } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useTutorialProgress } from '../useTutorialProgress';

// Mock react-admin hooks
vi.mock('react-admin', () => ({
  useGetIdentity: () => ({ data: { id: 1 }, isLoading: false }),
  useDataProvider: () => ({
    getList: vi.fn().mockResolvedValue({ data: [], total: 0 }),
    create: vi.fn().mockResolvedValue({ data: { id: 1 } }),
    update: vi.fn().mockResolvedValue({ data: { id: 1 } }),
  }),
}));

describe('useTutorialProgress', () => {
  it('returns loading state initially', () => {
    const { result } = renderHook(() => useTutorialProgress());
    expect(result.current.isLoading).toBe(true);
  });

  it('shows wizard when no progress exists', async () => {
    const { result } = renderHook(() => useTutorialProgress());
    await waitFor(() => {
      expect(result.current.shouldShowWizard).toBe(true);
    });
  });

  it('hides wizard when dismissed', async () => {
    vi.mocked(useDataProvider).mockReturnValue({
      getList: vi.fn().mockResolvedValue({
        data: [{ id: 1, dismissed: true }],
        total: 1
      }),
    });

    const { result } = renderHook(() => useTutorialProgress());
    await waitFor(() => {
      expect(result.current.shouldShowWizard).toBe(false);
    });
  });
});
```

**Step 2: Verify test fails**

```bash
npm test -- src/atomic-crm/tutorial/__tests__/useTutorialProgress.test.ts
```

**Expected:** Test fails (module not found)

**Step 3: Implement the hook**

```typescript
// src/atomic-crm/tutorial/useTutorialProgress.ts
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useGetIdentity, useDataProvider } from 'react-admin';
import type { TutorialProgress, TutorialStepId, WizardStatus } from './validation/tutorial';

interface UseTutorialProgressReturn {
  // State
  progress: TutorialProgress | null;
  isLoading: boolean;
  shouldShowWizard: boolean;
  wizardStatus: WizardStatus;
  currentStepId: TutorialStepId;

  // Created record IDs for linking
  createdOrganizationId: number | null;
  createdContactId: number | null;
  createdOpportunityId: number | null;

  // Actions
  markStepComplete: (stepId: TutorialStepId, recordId?: number) => Promise<void>;
  dismissWizard: (permanent: boolean) => Promise<void>;
  refetch: () => Promise<void>;
}

/**
 * Determine current step based on completion status
 */
const getCurrentStepId = (progress: TutorialProgress | null): TutorialStepId => {
  if (!progress) return 'organization';
  if (!progress.organization_completed) return 'organization';
  if (!progress.contact_completed) return 'contact';
  if (!progress.opportunity_completed) return 'opportunity';
  if (!progress.activity_completed) return 'activity';
  if (!progress.task_completed) return 'task';
  return 'task'; // All complete
};

/**
 * Check if all steps are complete
 */
const isAllComplete = (progress: TutorialProgress): boolean => {
  return (
    progress.organization_completed &&
    progress.contact_completed &&
    progress.opportunity_completed &&
    progress.activity_completed &&
    progress.task_completed
  );
};

export function useTutorialProgress(): UseTutorialProgressReturn {
  const { data: identity, isLoading: identityLoading } = useGetIdentity();
  const dataProvider = useDataProvider();

  const [progress, setProgress] = useState<TutorialProgress | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [wizardStatus, setWizardStatus] = useState<WizardStatus>('loading');

  // Fetch progress on mount
  const fetchProgress = useCallback(async () => {
    if (!identity?.id) return;

    setIsLoading(true);
    // NO try/catch - fail fast (Constitution compliance)
    const { data } = await dataProvider.getList('tutorial_progress', {
      filter: { sales_id: identity.id },
      pagination: { page: 1, perPage: 1 },
      sort: { field: 'id', order: 'DESC' },
    });

    const record = data[0] || null;
    setProgress(record);

    // Determine wizard status
    if (!record) {
      setWizardStatus('show');
    } else if (record.dismissed) {
      setWizardStatus('hide');
    } else if (isAllComplete(record)) {
      setWizardStatus('complete');
    } else {
      setWizardStatus('show');
    }

    setIsLoading(false);
  }, [identity?.id, dataProvider]);

  useEffect(() => {
    if (!identityLoading && identity?.id) {
      fetchProgress();
    }
  }, [identityLoading, identity?.id, fetchProgress]);

  // Mark step complete and optionally store created record ID
  const markStepComplete = useCallback(async (
    stepId: TutorialStepId,
    recordId?: number
  ) => {
    if (!identity?.id) return;

    const stepFieldMap: Record<TutorialStepId, string> = {
      organization: 'organization_completed',
      contact: 'contact_completed',
      opportunity: 'opportunity_completed',
      activity: 'activity_completed',
      task: 'task_completed',
    };

    const recordIdFieldMap: Record<TutorialStepId, string> = {
      organization: 'created_organization_id',
      contact: 'created_contact_id',
      opportunity: 'created_opportunity_id',
      activity: 'created_activity_id',
      task: 'created_task_id',
    };

    const updateData: Record<string, unknown> = {
      [stepFieldMap[stepId]]: true,
    };

    if (recordId) {
      updateData[recordIdFieldMap[stepId]] = recordId;
    }

    if (progress?.id) {
      await dataProvider.update('tutorial_progress', {
        id: progress.id,
        data: updateData,
        previousData: progress,
      });
    } else {
      await dataProvider.create('tutorial_progress', {
        data: {
          sales_id: identity.id,
          ...updateData,
        },
      });
    }

    await fetchProgress();
  }, [identity?.id, progress, dataProvider, fetchProgress]);

  // Dismiss wizard
  const dismissWizard = useCallback(async (permanent: boolean) => {
    if (!identity?.id) return;

    if (permanent) {
      if (progress?.id) {
        await dataProvider.update('tutorial_progress', {
          id: progress.id,
          data: {
            dismissed: true,
            dismissed_at: new Date().toISOString()
          },
          previousData: progress,
        });
      } else {
        await dataProvider.create('tutorial_progress', {
          data: {
            sales_id: identity.id,
            dismissed: true,
            dismissed_at: new Date().toISOString(),
          },
        });
      }
    }

    setWizardStatus('hide');
  }, [identity?.id, progress, dataProvider]);

  // Derived values
  const shouldShowWizard = wizardStatus === 'show';
  const currentStepId = getCurrentStepId(progress);

  return {
    progress,
    isLoading: isLoading || identityLoading,
    shouldShowWizard,
    wizardStatus,
    currentStepId,
    createdOrganizationId: progress?.created_organization_id ?? null,
    createdContactId: progress?.created_contact_id ?? null,
    createdOpportunityId: progress?.created_opportunity_id ?? null,
    markStepComplete,
    dismissWizard,
    refetch: fetchProgress,
  };
}
```

**Step 4: Verify test passes**

```bash
npm test -- src/atomic-crm/tutorial/__tests__/useTutorialProgress.test.ts
```

---

### Task 5: Wizard Configuration

**Depends on:** Task 4

**Constitution Check:**
- [x] Using `interface` for step config shape
- [x] Declarative configuration (recommended by Gemini review)

**Files:**
- Create: `src/atomic-crm/tutorial/wizardConfig.ts`

```typescript
// src/atomic-crm/tutorial/wizardConfig.ts
import type { TutorialStepId } from './validation/tutorial';

/**
 * Step configuration interface (Constitution: interface for objects)
 */
interface StepConfig {
  id: TutorialStepId;
  label: string;
  description: string;
}

/**
 * Declarative wizard step configuration
 * Order matters - this defines the wizard flow
 */
export const WIZARD_STEPS: readonly StepConfig[] = [
  {
    id: 'organization',
    label: 'Organization',
    description: 'Create your first organization - a company you work with.',
  },
  {
    id: 'contact',
    label: 'Contact',
    description: 'Add a contact at the organization you just created.',
  },
  {
    id: 'opportunity',
    label: 'Opportunity',
    description: 'Create a sales opportunity for this organization.',
  },
  {
    id: 'activity',
    label: 'Activity',
    description: 'Log your first activity on this opportunity.',
  },
  {
    id: 'task',
    label: 'Task',
    description: 'Create a follow-up task to stay on track.',
  },
] as const;

/**
 * Get step index by ID
 */
export const getStepIndex = (stepId: TutorialStepId): number =>
  WIZARD_STEPS.findIndex((s) => s.id === stepId);

/**
 * Get step config by ID
 */
export const getStepConfig = (stepId: TutorialStepId): StepConfig | undefined =>
  WIZARD_STEPS.find((s) => s.id === stepId);

/**
 * Total number of steps
 */
export const TOTAL_STEPS = WIZARD_STEPS.length;
```

---

### Task 6: TutorialProvider Context

**Depends on:** Task 5

**Constitution Check:**
- [x] Using `interface` for context value shape
- [x] No retry logic
- [x] Fail fast on errors

**Files:**
- Create: `src/atomic-crm/tutorial/TutorialProvider.tsx`

**Step 1: Create the provider**

```tsx
// src/atomic-crm/tutorial/TutorialProvider.tsx
import { createContext, useContext, useState, useCallback, type ReactNode } from 'react';
import { useTutorialProgress } from './useTutorialProgress';
import type { TutorialStepId, WizardStatus } from './validation/tutorial';

/**
 * Context value interface (Constitution: interface for objects)
 */
interface TutorialContextValue {
  // State from hook
  isLoading: boolean;
  shouldShowWizard: boolean;
  wizardStatus: WizardStatus;
  currentStepId: TutorialStepId;
  createdOrganizationId: number | null;
  createdContactId: number | null;
  createdOpportunityId: number | null;

  // Modal state
  isOpen: boolean;

  // Actions
  openWizard: () => void;
  closeWizard: () => void;
  goToNextStep: () => void;
  goToPreviousStep: () => void;
  markStepComplete: (stepId: TutorialStepId, recordId?: number) => Promise<void>;
  dismissWizard: (permanent: boolean) => Promise<void>;
}

const TutorialContext = createContext<TutorialContextValue | null>(null);

/**
 * Step order for navigation
 */
const STEP_ORDER: TutorialStepId[] = [
  'organization',
  'contact',
  'opportunity',
  'activity',
  'task',
];

interface TutorialProviderProps {
  children: ReactNode;
}

export function TutorialProvider({ children }: TutorialProviderProps) {
  const {
    isLoading,
    shouldShowWizard,
    wizardStatus,
    currentStepId,
    createdOrganizationId,
    createdContactId,
    createdOpportunityId,
    markStepComplete: markStepCompleteFromHook,
    dismissWizard: dismissWizardFromHook,
  } = useTutorialProgress();

  const [isOpen, setIsOpen] = useState(false);
  const [activeStepId, setActiveStepId] = useState<TutorialStepId>(currentStepId);

  // Open wizard when shouldShowWizard becomes true
  // Using useEffect would cause flicker - check on render instead
  const effectiveIsOpen = isOpen || (shouldShowWizard && !isLoading);

  const openWizard = useCallback(() => setIsOpen(true), []);
  const closeWizard = useCallback(() => setIsOpen(false), []);

  const goToNextStep = useCallback(() => {
    const currentIndex = STEP_ORDER.indexOf(activeStepId);
    if (currentIndex < STEP_ORDER.length - 1) {
      setActiveStepId(STEP_ORDER[currentIndex + 1]);
    }
  }, [activeStepId]);

  const goToPreviousStep = useCallback(() => {
    const currentIndex = STEP_ORDER.indexOf(activeStepId);
    if (currentIndex > 0) {
      setActiveStepId(STEP_ORDER[currentIndex - 1]);
    }
  }, [activeStepId]);

  const markStepComplete = useCallback(async (
    stepId: TutorialStepId,
    recordId?: number
  ) => {
    await markStepCompleteFromHook(stepId, recordId);
    goToNextStep();
  }, [markStepCompleteFromHook, goToNextStep]);

  const dismissWizard = useCallback(async (permanent: boolean) => {
    await dismissWizardFromHook(permanent);
    setIsOpen(false);
  }, [dismissWizardFromHook]);

  const value: TutorialContextValue = {
    isLoading,
    shouldShowWizard,
    wizardStatus,
    currentStepId: activeStepId,
    createdOrganizationId,
    createdContactId,
    createdOpportunityId,
    isOpen: effectiveIsOpen,
    openWizard,
    closeWizard,
    goToNextStep,
    goToPreviousStep,
    markStepComplete,
    dismissWizard,
  };

  return (
    <TutorialContext.Provider value={value}>
      {children}
    </TutorialContext.Provider>
  );
}

/**
 * Hook to access tutorial context
 * Throws if used outside provider (fail fast)
 */
export function useTutorialContext(): TutorialContextValue {
  const context = useContext(TutorialContext);
  if (!context) {
    throw new Error('useTutorialContext must be used within TutorialProvider');
  }
  return context;
}
```

---

### Task 6: TutorialWizard Modal Container

**Depends on:** Task 5

**Constitution Check:**
- [x] Touch targets: 44x44px minimum (h-11 w-11)
- [x] Semantic colors only
- [x] No retry logic

**Files:**
- Create: `src/atomic-crm/tutorial/TutorialWizard.tsx`

**Implementation:**

```tsx
// src/atomic-crm/tutorial/TutorialWizard.tsx
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { useTutorialContext } from './TutorialProvider';
import { TutorialStepIndicator } from './components/TutorialStepIndicator';
import { TutorialStepContent } from './components/TutorialStepContent';
import { TutorialDismissCheckbox } from './components/TutorialDismissCheckbox';
import { TutorialSuccessMessage } from './components/TutorialSuccessMessage';

export function TutorialWizard() {
  const {
    isOpen,
    isLoading,
    wizardStatus,
    currentStepId,
    closeWizard,
    goToPreviousStep,
    dismissWizard,
  } = useTutorialContext();

  // Don't render while loading to prevent flicker
  if (isLoading) return null;

  const isFirstStep = currentStepId === 'organization';
  const isComplete = wizardStatus === 'complete';

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && closeWizard()}>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle className="text-xl">
            Welcome to Crispy CRM
          </DialogTitle>
          <DialogDescription>
            Let's create your first records. This will only take a few minutes.
          </DialogDescription>
          <TutorialStepIndicator currentStepId={currentStepId} />
        </DialogHeader>

        <div className="py-4 min-h-[300px]">
          {isComplete ? (
            <TutorialSuccessMessage />
          ) : (
            <TutorialStepContent stepId={currentStepId} />
          )}
        </div>

        <DialogFooter className="flex-col sm:flex-row gap-2">
          <div className="flex items-center gap-2 mr-auto">
            <TutorialDismissCheckbox onDismiss={dismissWizard} />
          </div>
          <div className="flex gap-2">
            {!isFirstStep && !isComplete && (
              <Button
                variant="outline"
                onClick={goToPreviousStep}
                className="h-11 min-w-[80px]" // 44px touch target
              >
                Back
              </Button>
            )}
            <Button
              variant="ghost"
              onClick={() => dismissWizard(false)}
              className="h-11" // 44px touch target
            >
              {isComplete ? 'Close' : 'Skip for now'}
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

---

## Phase 3: UI Components (Parallel Tasks 7-9)

### Task 7: TutorialStepIndicator

**Depends on:** Task 5
**Can parallelize with:** Tasks 8, 9

**Files:**
- Create: `src/atomic-crm/tutorial/components/TutorialStepIndicator.tsx`

```tsx
// src/atomic-crm/tutorial/components/TutorialStepIndicator.tsx
import { Progress } from '@/components/ui/progress';
import type { TutorialStepId } from '../validation/tutorial';

interface StepConfig {
  id: TutorialStepId;
  label: string;
}

const STEPS: StepConfig[] = [
  { id: 'organization', label: 'Organization' },
  { id: 'contact', label: 'Contact' },
  { id: 'opportunity', label: 'Opportunity' },
  { id: 'activity', label: 'Activity' },
  { id: 'task', label: 'Task' },
];

interface TutorialStepIndicatorProps {
  currentStepId: TutorialStepId;
}

export function TutorialStepIndicator({ currentStepId }: TutorialStepIndicatorProps) {
  const currentIndex = STEPS.findIndex((s) => s.id === currentStepId);
  const progressValue = ((currentIndex + 1) / STEPS.length) * 100;

  return (
    <div className="space-y-2 pt-4">
      <div className="flex justify-between text-sm text-muted-foreground">
        <span>Step {currentIndex + 1} of {STEPS.length}</span>
        <span className="font-medium text-foreground">
          {STEPS[currentIndex]?.label}
        </span>
      </div>
      <Progress
        value={progressValue}
        aria-label={`Tutorial progress: Step ${currentIndex + 1} of ${STEPS.length}`}
        className="h-2"
      />
    </div>
  );
}
```

---

### Task 8: TutorialStepContent

**Depends on:** Task 5
**Can parallelize with:** Tasks 7, 9

**Files:**
- Create: `src/atomic-crm/tutorial/components/TutorialStepContent.tsx`

```tsx
// src/atomic-crm/tutorial/components/TutorialStepContent.tsx
import { Suspense, lazy } from 'react';
import { Skeleton } from '@/components/ui/skeleton';
import type { TutorialStepId } from '../validation/tutorial';

// Lazy load step components for code splitting
const OrganizationStep = lazy(() => import('../steps/OrganizationStep'));
const ContactStep = lazy(() => import('../steps/ContactStep'));
const OpportunityStep = lazy(() => import('../steps/OpportunityStep'));
const ActivityStep = lazy(() => import('../steps/ActivityStep'));
const TaskStep = lazy(() => import('../steps/TaskStep'));

interface TutorialStepContentProps {
  stepId: TutorialStepId;
}

const STEP_COMPONENTS: Record<TutorialStepId, React.LazyExoticComponent<() => JSX.Element>> = {
  organization: OrganizationStep,
  contact: ContactStep,
  opportunity: OpportunityStep,
  activity: ActivityStep,
  task: TaskStep,
};

export function TutorialStepContent({ stepId }: TutorialStepContentProps) {
  const StepComponent = STEP_COMPONENTS[stepId];

  return (
    <Suspense fallback={<StepSkeleton />}>
      <StepComponent />
    </Suspense>
  );
}

function StepSkeleton() {
  return (
    <div className="space-y-4">
      <Skeleton className="h-10 w-full" />
      <Skeleton className="h-10 w-full" />
      <Skeleton className="h-10 w-2/3" />
    </div>
  );
}
```

---

### Task 9: TutorialDismissCheckbox

**Depends on:** Task 5
**Can parallelize with:** Tasks 7, 8

**Files:**
- Create: `src/atomic-crm/tutorial/components/TutorialDismissCheckbox.tsx`

```tsx
// src/atomic-crm/tutorial/components/TutorialDismissCheckbox.tsx
import { useState } from 'react';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';

interface TutorialDismissCheckboxProps {
  onDismiss: (permanent: boolean) => Promise<void>;
}

export function TutorialDismissCheckbox({ onDismiss }: TutorialDismissCheckboxProps) {
  const [checked, setChecked] = useState(false);

  const handleChange = async (isChecked: boolean) => {
    setChecked(isChecked);
    if (isChecked) {
      await onDismiss(true);
    }
  };

  return (
    <div className="flex items-center gap-2">
      <Checkbox
        id="dismiss-tutorial"
        checked={checked}
        onCheckedChange={handleChange}
        className="h-5 w-5" // Larger for touch
      />
      <Label
        htmlFor="dismiss-tutorial"
        className="text-sm text-muted-foreground cursor-pointer"
      >
        Don't show this again
      </Label>
    </div>
  );
}
```

---

## Phase 4: Step Forms (Parallel Tasks 10-14)

> **Note:** All step forms follow the same pattern with progressive disclosure.
> Only Task 10 (OrganizationStep) is shown in full detail.
> Tasks 11-14 follow the same structure with different fields.

### Task 10: OrganizationStep

**Depends on:** Task 8
**Can parallelize with:** Tasks 11-14

**Files:**
- Create: `src/atomic-crm/tutorial/steps/OrganizationStep.tsx`

```tsx
// src/atomic-crm/tutorial/steps/OrganizationStep.tsx
import { useState } from 'react';
import { useGetIdentity, useCreate, useNotify } from 'react-admin';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import { ChevronDown } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useTutorialContext } from '../TutorialProvider';
import { organizationSchema } from '@/atomic-crm/validation/organizations';

// Constitution: Form defaults from schema
const defaultValues = organizationSchema.partial().parse({});

const ORGANIZATION_TYPES = [
  { value: 'prospect', label: 'Prospect' },
  { value: 'customer', label: 'Customer' },
  { value: 'distributor', label: 'Distributor' },
  { value: 'principal', label: 'Principal' },
];

export default function OrganizationStep() {
  const { data: identity } = useGetIdentity();
  const [create, { isLoading }] = useCreate();
  const notify = useNotify();
  const { markStepComplete } = useTutorialContext();

  const [showMore, setShowMore] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    organization_type: defaultValues.organization_type || 'prospect',
    website: '',
    phone: '',
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Constitution: No try/catch - fail fast
    const result = await create('organizations', {
      data: {
        ...formData,
        sales_id: identity?.id,
      },
    }, { returnPromise: true });

    await markStepComplete('organization', result.id as number);
    notify('Organization created!', { type: 'success' });
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="space-y-2">
        <p className="text-sm text-muted-foreground">
          Start by creating an organization. This could be a prospect, customer,
          or distributor you work with.
        </p>
      </div>

      {/* Required fields */}
      <div className="space-y-2">
        <Label htmlFor="org-name">Organization Name *</Label>
        <Input
          id="org-name"
          value={formData.name}
          onChange={(e) => setFormData({ ...formData, name: e.target.value })}
          placeholder="e.g., Acme Foods"
          required
          className="h-11" // 44px touch target
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="org-type">Type *</Label>
        <Select
          value={formData.organization_type}
          onValueChange={(value) => setFormData({ ...formData, organization_type: value })}
        >
          <SelectTrigger id="org-type" className="h-11">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {ORGANIZATION_TYPES.map((type) => (
              <SelectItem key={type.value} value={type.value}>
                {type.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Progressive disclosure */}
      <Collapsible open={showMore} onOpenChange={setShowMore}>
        <CollapsibleTrigger asChild>
          <Button variant="ghost" size="sm" type="button" className="gap-1">
            {showMore ? 'Show fewer fields' : 'Show more fields'}
            <ChevronDown className={cn('h-4 w-4 transition-transform', showMore && 'rotate-180')} />
          </Button>
        </CollapsibleTrigger>
        <CollapsibleContent className="space-y-4 pt-4">
          <div className="space-y-2">
            <Label htmlFor="org-website">Website</Label>
            <Input
              id="org-website"
              type="url"
              value={formData.website}
              onChange={(e) => setFormData({ ...formData, website: e.target.value })}
              placeholder="https://example.com"
              className="h-11"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="org-phone">Phone</Label>
            <Input
              id="org-phone"
              type="tel"
              value={formData.phone}
              onChange={(e) => setFormData({ ...formData, phone: e.target.value })}
              placeholder="(555) 123-4567"
              className="h-11"
            />
          </div>
        </CollapsibleContent>
      </Collapsible>

      <Button
        type="submit"
        disabled={isLoading || !formData.name}
        className="w-full h-11"
      >
        {isLoading ? 'Creating...' : 'Create & Continue'}
      </Button>
    </form>
  );
}
```

---

### Tasks 11-14: Remaining Step Forms

> **Pattern:** Same as Task 10 with different fields.
> See "Minimal Fields Per Step" table in overview.

| Task | File | Required Fields |
|------|------|-----------------|
| 11 | `steps/ContactStep.tsx` | first_name, last_name (org pre-filled) |
| 12 | `steps/OpportunityStep.tsx` | name, stage (org pre-filled) |
| 13 | `steps/ActivityStep.tsx` | type, subject (opp pre-filled) |
| 14 | `steps/TaskStep.tsx` | title, due_date (opp pre-filled) |

---

## Phase 5: Integration

### Task 15: TutorialSuccessMessage

**Depends on:** Tasks 10-14

**Files:**
- Create: `src/atomic-crm/tutorial/components/TutorialSuccessMessage.tsx`

```tsx
// src/atomic-crm/tutorial/components/TutorialSuccessMessage.tsx
import { CheckCircle } from 'lucide-react';

export function TutorialSuccessMessage() {
  return (
    <div className="flex flex-col items-center justify-center py-8 text-center">
      <CheckCircle className="h-16 w-16 text-primary mb-4" />
      <h3 className="text-xl font-semibold mb-2">
        You're all set!
      </h3>
      <p className="text-muted-foreground max-w-sm">
        You've created your first organization, contact, opportunity, activity,
        and task. You're ready to start managing your sales pipeline!
      </p>
    </div>
  );
}
```

---

### Task 16: Module Index

**Depends on:** Task 15

**Files:**
- Create: `src/atomic-crm/tutorial/index.tsx`

```tsx
// src/atomic-crm/tutorial/index.tsx
export { TutorialProvider, useTutorialContext } from './TutorialProvider';
export { TutorialWizard } from './TutorialWizard';
export { useTutorialProgress } from './useTutorialProgress';
export type { TutorialStepId, TutorialProgress, WizardStatus } from './validation/tutorial';
```

---

### Task 17: Layout Integration

**Depends on:** Task 16

**Files:**
- Modify: `src/atomic-crm/layout/Layout.tsx`

**Step 1: Add imports**

```tsx
import { TutorialProvider, TutorialWizard } from '../tutorial';
```

**Step 2: Wrap children with TutorialProvider**

Find the `<main>` element and wrap its children:

```tsx
<main className="..." id="main-content" tabIndex={-1}>
  <ErrorBoundary FallbackComponent={Error}>
    <Suspense fallback={<Skeleton className="h-12 w-12 rounded-full" />}>
      <TutorialProvider>
        {children}
        <TutorialWizard />
      </TutorialProvider>
    </Suspense>
  </ErrorBoundary>
</main>
```

---

## Phase 6: Testing (Parallel Tasks 18-19)

### Task 18: Unit Tests

**Depends on:** Task 17
**Can parallelize with:** Task 19

**Files:**
- Create: `src/atomic-crm/tutorial/__tests__/TutorialProvider.test.tsx`
- Create: `src/atomic-crm/tutorial/__tests__/TutorialWizard.test.tsx`

### Task 19: E2E Test

**Depends on:** Task 17
**Can parallelize with:** Task 18

**Files:**
- Create: `tests/e2e/tutorial-wizard.spec.ts`

```typescript
// tests/e2e/tutorial-wizard.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Tutorial Wizard', () => {
  test('shows on first login', async ({ page }) => {
    // Login as new user (no tutorial_progress record)
    await page.goto('/');
    await page.fill('[name="email"]', 'newuser@test.com');
    await page.fill('[name="password"]', 'password');
    await page.click('button[type="submit"]');

    // Wizard should appear
    await expect(page.getByRole('dialog')).toBeVisible();
    await expect(page.getByText('Welcome to Crispy CRM')).toBeVisible();
  });

  test('completes full wizard flow', async ({ page }) => {
    // ... test implementation
  });

  test('respects "Don\'t show again" checkbox', async ({ page }) => {
    // ... test implementation
  });
});
```

---

## Execution Handoff

**Plan saved to:** `docs/plans/2025-12-06-tutorial-wizard.md`

**Total Tasks:** 20

### Parallel Execution Strategy

```
GROUP A (Sequential): Tasks 1 → 2 → 3
GROUP B (Sequential): Tasks 4 → 5 → 6 → 7
GROUP C (Parallel):   Tasks 8, 9, 10 (after Task 6)
GROUP D (Parallel):   Tasks 11, 12, 13, 14, 15 (after Task 9)
GROUP E (Sequential): Tasks 16 → 17 → 18
GROUP F (Parallel):   Tasks 19, 20 (after Task 18)
```

### To Execute

**Sequential mode:**
```
Execute each task in order. Run tests after each phase.
```

**Parallel mode:**
```
Spawn agents per group. Coordinate at group boundaries.
Group C and D have highest parallelization opportunity (8 tasks).
```

---

## Constitution Compliance Checklist (Final)

Before marking this plan as complete, verify:

- [x] No retry logic anywhere in plan
- [x] No circuit breakers
- [x] Validation only at API boundary (data provider)
- [x] Form defaults from `schema.partial().parse({})`
- [x] All data through unifiedDataProvider
- [x] `interface` for objects, `type` for unions
- [x] Touch targets: h-11 (44px) minimum
- [x] Semantic colors only (no hardcoded hex)
