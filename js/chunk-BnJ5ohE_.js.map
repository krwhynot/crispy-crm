{"version":3,"file":"chunk-BnJ5ohE_.js","sources":["../../src/atomic-crm/utils/csvUploadValidator.ts"],"sourcesContent":["/**\n * CSV Upload Security Validation\n * Prevents DoS, injection attacks, and malicious file uploads\n *\n * Phase 1 Security Remediation - CRITICAL\n *\n * Protects against:\n * - File size attacks (DoS via massive files)\n * - MIME type spoofing (executables renamed to .csv)\n * - Formula injection (=cmd|'/c calc'!A0)\n * - Binary file uploads (malware)\n * - Memory exhaustion (billion row CSVs)\n *\n * @module csvUploadValidator\n */\n\nexport const CSV_UPLOAD_LIMITS = {\n  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB\n  MAX_ROWS: 10000,\n  MAX_CELL_LENGTH: 1000,\n  ALLOWED_MIME_TYPES: [\"text/csv\", \"text/plain\", \"application/vnd.ms-excel\"],\n  ALLOWED_EXTENSIONS: [\".csv\"],\n} as const;\n\nexport interface CsvValidationError {\n  field: string;\n  message: string;\n  code: \"SIZE\" | \"MIME\" | \"STRUCTURE\" | \"ENCODING\" | \"BINARY\";\n}\n\nexport interface CsvValidationResult {\n  valid: boolean;\n  errors?: CsvValidationError[];\n  warnings?: string[];\n}\n\n/**\n * Validate CSV file before processing\n * Runs client-side as first line of defense\n *\n * @param file - File object from input\n * @returns Validation result with errors/warnings\n *\n * @example\n * const result = await validateCsvFile(file);\n * if (!result.valid) {\n *   alert(result.errors.map(e => e.message).join('\\n'));\n *   return;\n * }\n */\nexport async function validateCsvFile(file: File): Promise<CsvValidationResult> {\n  const errors: CsvValidationError[] = [];\n  const warnings: string[] = [];\n\n  // 1. File size check (DoS prevention)\n  if (file.size > CSV_UPLOAD_LIMITS.MAX_FILE_SIZE) {\n    errors.push({\n      field: \"size\",\n      message: `File size (${formatBytes(file.size)}) exceeds limit of ${formatBytes(CSV_UPLOAD_LIMITS.MAX_FILE_SIZE)}`,\n      code: \"SIZE\",\n    });\n  }\n\n  if (file.size === 0) {\n    errors.push({\n      field: \"size\",\n      message: \"File is empty\",\n      code: \"SIZE\",\n    });\n  }\n\n  // 2. File extension check\n  const hasValidExtension = CSV_UPLOAD_LIMITS.ALLOWED_EXTENSIONS.some((ext) =>\n    file.name.toLowerCase().endsWith(ext)\n  );\n\n  if (!hasValidExtension) {\n    errors.push({\n      field: \"extension\",\n      message: `File must have .csv extension. Got: ${file.name}`,\n      code: \"MIME\",\n    });\n  }\n\n  // 3. MIME type check (weak protection, but catches obvious mistakes)\n  if (file.type && !CSV_UPLOAD_LIMITS.ALLOWED_MIME_TYPES.includes(file.type)) {\n    warnings.push(`MIME type \"${file.type}\" is unusual for CSV. Expected: text/csv`);\n  }\n\n  // 4. Content sniffing - read first bytes to detect binary files\n  try {\n    const chunk = await file.slice(0, 1024).text();\n\n    // Check for binary file signatures (magic bytes)\n    if (isBinaryFile(chunk)) {\n      errors.push({\n        field: \"content\",\n        message: \"File appears to be binary, not text. Only CSV text files allowed.\",\n        code: \"BINARY\",\n      });\n    }\n\n    // Check for CSV structure (should have delimiters)\n    if (!/[,\\t;|]/.test(chunk)) {\n      errors.push({\n        field: \"structure\",\n        message: \"File does not appear to be CSV format (no delimiters found)\",\n        code: \"STRUCTURE\",\n      });\n    }\n\n    // Check for valid text encoding\n    if (/[\\\\x00-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F]/.test(chunk)) {\n      warnings.push(\"File may contain control characters or binary data\");\n    }\n  } catch {\n    errors.push({\n      field: \"encoding\",\n      message: \"Unable to read file. Ensure it is valid UTF-8 encoded text.\",\n      code: \"ENCODING\",\n    });\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors: errors.length > 0 ? errors : undefined,\n    warnings: warnings.length > 0 ? warnings : undefined,\n  };\n}\n\n/**\n * Detect binary files by checking for common magic bytes\n *\n * @param chunk - First 1024 bytes of file as string\n * @returns true if file appears to be binary\n */\nfunction isBinaryFile(chunk: string): boolean {\n  const binarySignatures = [\n    \"\\xFF\\xD8\\xFF\", // JPEG\n    \"\\x89PNG\", // PNG\n    \"GIF8\", // GIF\n    \"\\x1F\\x8B\", // GZIP\n    \"PK\\x03\\x04\", // ZIP\n    \"PK\\x05\\x06\", // ZIP (empty)\n    \"\\x00\\x00\\x00\", // Various binary formats\n    \"MZ\", // EXE\n    \"\\x7FELF\", // Linux executable\n    \"%PDF\", // PDF\n    \"\\xD0\\xCF\\x11\\xE0\", // MS Office (old format)\n  ];\n\n  return binarySignatures.some((sig) => chunk.startsWith(sig));\n}\n\n/**\n * Configure PapaParse with security settings\n * Prevents formula injection and limits resource usage\n *\n * @returns PapaParse configuration object\n *\n * @example\n * const { parseCsv } = usePapaParse({\n *   papaConfig: getSecurePapaParseConfig()\n * });\n */\nexport function getSecurePapaParseConfig() {\n  return {\n    header: true,\n    dynamicTyping: false, // CRITICAL: Prevent automatic type conversion\n    skipEmptyLines: true,\n    preview: CSV_UPLOAD_LIMITS.MAX_ROWS, // Limit rows processed\n\n    // Sanitize headers\n    transformHeader: (header: string) => {\n      return header\n        .trim()\n        .toLowerCase()\n        .replace(/[^a-z0-9_\\s]/g, \"_\")\n        .substring(0, 100); // Limit header length\n    },\n\n    // Sanitize cell values (formula injection prevention)\n    transform: (value: string, _field: string) => {\n      if (typeof value !== \"string\") return value;\n\n      // Remove formula injection attempts\n      const trimmed = value.trim();\n      if (/^[=+\\-@\\t\\r]/.test(trimmed)) {\n        // Prepend single quote to prevent formula evaluation\n        return \"'\" + trimmed;\n      }\n\n      // Limit cell length\n      if (trimmed.length > CSV_UPLOAD_LIMITS.MAX_CELL_LENGTH) {\n        return trimmed.substring(0, CSV_UPLOAD_LIMITS.MAX_CELL_LENGTH) + \"...\";\n      }\n\n      return trimmed;\n    },\n\n    // Error handling\n    error: (error: any) => {\n      console.error(\"[CSV Security] Parse error:\", error.message);\n      throw new Error(`CSV parsing failed: ${error.message}`);\n    },\n  };\n}\n\n/**\n * Sanitize individual CSV cell value\n * Additional layer beyond PapaParse transform\n *\n * @param value - Raw cell value\n * @returns Sanitized string\n *\n * @example\n * const safe = sanitizeCsvValue(\"=cmd|'/c calc'!A0\");\n * // Returns: \"'=cmd|'/c calc'!A0\"\n */\nexport function sanitizeCsvValue(value: any): string {\n  if (!value || typeof value !== \"string\") {\n    return \"\";\n  }\n\n  let sanitized = value.trim();\n\n  // 1. Formula injection prevention\n  if (/^[=+\\-@\\t\\r]/.test(sanitized)) {\n    sanitized = \"'\" + sanitized;\n  }\n\n  // 2. Remove control characters\n  // eslint-disable-next-line no-control-regex\n  sanitized = sanitized.replace(/[\\x00-\\x1F\\x7F]/g, \"\");\n\n  // 3. Remove potential HTML/script tags\n  sanitized = sanitized.replace(/<[^>]*>/g, \"\");\n\n  // 4. Limit length\n  if (sanitized.length > CSV_UPLOAD_LIMITS.MAX_CELL_LENGTH) {\n    sanitized = sanitized.substring(0, CSV_UPLOAD_LIMITS.MAX_CELL_LENGTH);\n  }\n\n  return sanitized;\n}\n\n/**\n * Format bytes for human-readable display\n *\n * @param bytes - Number of bytes\n * @returns Formatted string (e.g., \"10.5 MB\")\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes === 0) return \"0 Bytes\";\n  const k = 1024;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + \" \" + sizes[i];\n}\n\n// ============================================================================\n// DUPLICATE DETECTION\n// Prevents importing contacts that already exist in the database\n// ============================================================================\n\n/**\n * Contact data for duplicate detection\n */\nexport interface ContactForDuplicateCheck {\n  first_name?: string;\n  last_name?: string;\n  organization_id?: number | null;\n}\n\n/**\n * Existing contact from database for comparison\n */\nexport interface ExistingContact {\n  id: number;\n  first_name: string | null;\n  last_name: string | null;\n  organization_id: number | null;\n  company_name?: string | null;\n}\n\n/**\n * Result of duplicate detection for a single contact\n */\nexport interface DuplicateMatch {\n  importIndex: number;\n  importContact: ContactForDuplicateCheck;\n  existingMatches: ExistingContact[];\n  action: \"skip\" | \"import\" | \"review\";\n}\n\n/**\n * Summary of duplicate detection results\n */\nexport interface DuplicateDetectionResult {\n  totalImported: number;\n  exactDuplicates: DuplicateMatch[];\n  possibleDuplicates: DuplicateMatch[];\n  cleanContacts: ContactForDuplicateCheck[];\n  duplicatesInFile: Array<{\n    name: string;\n    indices: number[];\n  }>;\n}\n\n/**\n * Normalize a name for comparison (lowercase, trim, collapse whitespace)\n */\nfunction normalizeName(name: string | null | undefined): string {\n  if (!name) return \"\";\n  return name.toLowerCase().trim().replace(/\\s+/g, \" \");\n}\n\n/**\n * Create a unique key for duplicate detection\n * Uses normalized (first_name + last_name + organization_id)\n */\nfunction createDuplicateKey(\n  firstName: string | null | undefined,\n  lastName: string | null | undefined,\n  orgId: number | null | undefined\n): string {\n  const normalizedFirst = normalizeName(firstName);\n  const normalizedLast = normalizeName(lastName);\n  const fullName = `${normalizedFirst} ${normalizedLast}`.trim();\n  return `${fullName}|${orgId ?? \"null\"}`;\n}\n\n/**\n * Detect duplicates in imported contacts against existing database contacts\n *\n * @param importedContacts - Contacts being imported from CSV\n * @param existingContacts - Existing contacts from database\n * @returns Duplicate detection results with categorized contacts\n *\n * @example\n * const result = detectDuplicates(csvContacts, existingDbContacts);\n * if (result.exactDuplicates.length > 0) {\n *   console.log(`Found ${result.exactDuplicates.length} exact duplicates`);\n * }\n */\nexport function detectDuplicates(\n  importedContacts: ContactForDuplicateCheck[],\n  existingContacts: ExistingContact[]\n): DuplicateDetectionResult {\n  const exactDuplicates: DuplicateMatch[] = [];\n  const possibleDuplicates: DuplicateMatch[] = [];\n  const cleanContacts: ContactForDuplicateCheck[] = [];\n\n  // Build index of existing contacts by normalized name\n  const existingByKey = new Map<string, ExistingContact[]>();\n  const existingByName = new Map<string, ExistingContact[]>();\n\n  for (const existing of existingContacts) {\n    // Full key (name + org)\n    const fullKey = createDuplicateKey(\n      existing.first_name,\n      existing.last_name,\n      existing.organization_id\n    );\n    if (!existingByKey.has(fullKey)) {\n      existingByKey.set(fullKey, []);\n    }\n    existingByKey.get(fullKey)!.push(existing);\n\n    // Name-only key (for possible duplicates)\n    const nameKey = createDuplicateKey(existing.first_name, existing.last_name, null);\n    if (!existingByName.has(nameKey)) {\n      existingByName.set(nameKey, []);\n    }\n    existingByName.get(nameKey)!.push(existing);\n  }\n\n  // Also detect duplicates within the import file itself\n  const importFileKeys = new Map<string, number[]>();\n\n  // Check each imported contact\n  importedContacts.forEach((contact, index) => {\n    const fullKey = createDuplicateKey(\n      contact.first_name,\n      contact.last_name,\n      contact.organization_id\n    );\n    const nameKey = createDuplicateKey(contact.first_name, contact.last_name, null);\n\n    // Track duplicates within the import file\n    if (!importFileKeys.has(fullKey)) {\n      importFileKeys.set(fullKey, []);\n    }\n    importFileKeys.get(fullKey)!.push(index);\n\n    // Check for exact duplicates (same name + same org)\n    const exactMatches = existingByKey.get(fullKey) || [];\n    if (exactMatches.length > 0) {\n      exactDuplicates.push({\n        importIndex: index,\n        importContact: contact,\n        existingMatches: exactMatches,\n        action: \"skip\",\n      });\n      return;\n    }\n\n    // Check for possible duplicates (same name, different org)\n    const nameMatches = existingByName.get(nameKey) || [];\n    if (nameMatches.length > 0) {\n      // Filter out matches with same org (already handled above)\n      const differentOrgMatches = nameMatches.filter(\n        (m) => m.organization_id !== contact.organization_id\n      );\n      if (differentOrgMatches.length > 0) {\n        possibleDuplicates.push({\n          importIndex: index,\n          importContact: contact,\n          existingMatches: differentOrgMatches,\n          action: \"review\",\n        });\n        // Still add to clean contacts - user can decide\n        cleanContacts.push(contact);\n        return;\n      }\n    }\n\n    // No duplicates found\n    cleanContacts.push(contact);\n  });\n\n  // Find duplicates within the import file\n  const duplicatesInFile: Array<{ name: string; indices: number[] }> = [];\n  for (const [key, indices] of importFileKeys.entries()) {\n    if (indices.length > 1) {\n      const [name] = key.split(\"|\");\n      duplicatesInFile.push({ name, indices });\n    }\n  }\n\n  return {\n    totalImported: importedContacts.length,\n    exactDuplicates,\n    possibleDuplicates,\n    cleanContacts,\n    duplicatesInFile,\n  };\n}\n\n/**\n * Generate a human-readable summary of duplicate detection results\n *\n * @param result - Duplicate detection result\n * @returns Formatted summary string\n */\nexport function formatDuplicateSummary(result: DuplicateDetectionResult): string {\n  const lines: string[] = [];\n\n  lines.push(`Duplicate Detection Summary:`);\n  lines.push(`- Total contacts in file: ${result.totalImported}`);\n  lines.push(`- Clean (ready to import): ${result.cleanContacts.length}`);\n  lines.push(`- Exact duplicates (will skip): ${result.exactDuplicates.length}`);\n  lines.push(`- Possible duplicates (need review): ${result.possibleDuplicates.length}`);\n\n  if (result.duplicatesInFile.length > 0) {\n    lines.push(`- Duplicates within file: ${result.duplicatesInFile.length}`);\n  }\n\n  return lines.join(\"\\n\");\n}\n"],"names":["CSV_UPLOAD_LIMITS","MAX_FILE_SIZE","MAX_ROWS","MAX_CELL_LENGTH","ALLOWED_MIME_TYPES","ALLOWED_EXTENSIONS","async","validateCsvFile","file","errors","warnings","size","push","field","message","formatBytes","code","some","ext","name","toLowerCase","endsWith","type","includes","chunk","slice","text","isBinaryFile","test","valid","length","sig","startsWith","getSecurePapaParseConfig","header","dynamicTyping","skipEmptyLines","preview","transformHeader","trim","replace","substring","transform","__name","value","_field","trimmed","error","Error","sanitizeCsvValue","sanitized","bytes","i","Math","floor","log","round","pow"],"mappings":"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"}