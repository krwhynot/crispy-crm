import {
  SyntaxKind,
  InterfaceDeclaration,
  TypeAliasDeclaration,
  PropertySignature,
} from "ts-morph";
import { project } from "../utils/project.js";
import { createEnvelope, writeDiscoveryFile } from "../utils/output.js";
import * as path from "path";

/**
 * Information about a single property in an interface.
 */
interface PropertyInfo {
  name: string;
  type: string;
  optional: boolean;
  readonly: boolean;
}

/**
 * Information about a TypeScript type (interface or type alias).
 */
interface TypeInfo {
  name: string;
  file: string;
  line: number;
  kind: "interface" | "type_alias";
  properties?: PropertyInfo[];
  extends?: string[];
  typeExpression?: string;
  isComplex: boolean;
  derivedFrom?: string;
  isExported: boolean;
  generics?: string[];
}

/**
 * Source globs for types extraction.
 * Excludes database.generated.ts (180KB auto-generated by Supabase).
 */
const SOURCE_GLOBS = [
  "src/atomic-crm/types.ts",
  "src/atomic-crm/**/types.ts",
  "src/types/**/*.ts",
];

/**
 * Files to exclude from extraction.
 */
const EXCLUDED_FILES = ["database.generated.ts"];

/**
 * Detect if a type alias is derived from z.infer<typeof X>.
 * Returns the schema name if it's a Zod infer type, undefined otherwise.
 */
function detectZodInfer(typeNode: TypeAliasDeclaration): string | undefined {
  const typeText = typeNode.getTypeNode()?.getText() || "";

  // Match patterns like: z.infer<typeof schemaName>
  const zodInferMatch = typeText.match(/z\.infer<typeof\s+(\w+)>/);
  if (zodInferMatch) {
    return zodInferMatch[1];
  }

  // Match patterns like: z.output<typeof schemaName>
  const zodOutputMatch = typeText.match(/z\.output<typeof\s+(\w+)>/);
  if (zodOutputMatch) {
    return zodOutputMatch[1];
  }

  // Match patterns like: z.input<typeof schemaName>
  const zodInputMatch = typeText.match(/z\.input<typeof\s+(\w+)>/);
  if (zodInputMatch) {
    return zodInputMatch[1];
  }

  return undefined;
}

/**
 * Determine if a type expression is "complex" (unions, intersections, conditionals, etc.)
 */
function isComplexType(typeExpression: string): boolean {
  // Complex indicators: unions, intersections, generics, conditionals
  const complexPatterns = [
    /\s*\|\s*/, // Union types
    /\s*&\s*/, // Intersection types
    /\?\s*.*\s*:/, // Conditional types
    /<[^>]+>/, // Generic instantiations (but not simple ones)
    /\{[^}]+\}/, // Object literals with multiple properties
  ];

  // Simple generics like Array<string> are not complex
  if (/^(Array|Promise|Record|Map|Set|Partial|Required|Pick|Omit)<[^<>]+>$/.test(typeExpression)) {
    return false;
  }

  return complexPatterns.some((pattern) => pattern.test(typeExpression));
}

/**
 * Extract properties from an interface declaration.
 */
function extractProperties(interfaceDecl: InterfaceDeclaration): PropertyInfo[] {
  const properties: PropertyInfo[] = [];

  for (const prop of interfaceDecl.getProperties()) {
    const propSignature = prop as PropertySignature;
    properties.push({
      name: propSignature.getName(),
      type: propSignature.getType().getText(propSignature),
      optional: propSignature.hasQuestionToken(),
      readonly: propSignature.isReadonly(),
    });
  }

  return properties;
}

/**
 * Extract generic type parameters from a declaration.
 */
function extractGenerics(
  decl: InterfaceDeclaration | TypeAliasDeclaration
): string[] | undefined {
  const typeParams = decl.getTypeParameters();
  if (typeParams.length === 0) return undefined;

  return typeParams.map((tp) => {
    const constraint = tp.getConstraint();
    const defaultType = tp.getDefault();
    let text = tp.getName();
    if (constraint) text += ` extends ${constraint.getText()}`;
    if (defaultType) text += ` = ${defaultType.getText()}`;
    return text;
  });
}

/**
 * Extract TypeInfo from an interface declaration.
 */
function extractFromInterface(
  decl: InterfaceDeclaration,
  filePath: string
): TypeInfo {
  const name = decl.getName();
  const extendsClause = decl.getExtends();
  const extendsNames = extendsClause.map((e) => e.getText());
  const properties = extractProperties(decl);
  const generics = extractGenerics(decl);

  return {
    name,
    file: path.relative(process.cwd(), filePath),
    line: decl.getStartLineNumber(),
    kind: "interface",
    properties,
    extends: extendsNames.length > 0 ? extendsNames : undefined,
    isComplex: properties.length > 5 || extendsNames.length > 0,
    isExported: decl.isExported(),
    generics,
  };
}

/**
 * Extract TypeInfo from a type alias declaration.
 */
function extractFromTypeAlias(
  decl: TypeAliasDeclaration,
  filePath: string
): TypeInfo {
  const name = decl.getName();
  const typeNode = decl.getTypeNode();
  const typeExpression = typeNode?.getText() || "unknown";
  const derivedFrom = detectZodInfer(decl);
  const generics = extractGenerics(decl);

  return {
    name,
    file: path.relative(process.cwd(), filePath),
    line: decl.getStartLineNumber(),
    kind: "type_alias",
    typeExpression,
    isComplex: isComplexType(typeExpression),
    derivedFrom,
    isExported: decl.isExported(),
    generics,
  };
}

/**
 * Check if a file should be excluded from extraction.
 */
function shouldExcludeFile(filePath: string): boolean {
  return EXCLUDED_FILES.some((excluded) => filePath.includes(excluded));
}

/**
 * Main extraction function for TypeScript types.
 */
export async function extractTypes(): Promise<void> {
  console.log("üìê Extracting TypeScript types...");

  // Use the return value to get ONLY the files matching our globs
  // (not all files accumulated in the project singleton)
  const sourceFiles = project.addSourceFilesAtPaths(SOURCE_GLOBS);
  const types: TypeInfo[] = [];
  const processedFiles = new Set<string>();

  for (const sourceFile of sourceFiles) {
    const filePath = sourceFile.getFilePath();

    // Skip excluded files
    if (shouldExcludeFile(filePath)) {
      console.log(`  ‚è≠Ô∏è  Skipping excluded file: ${path.basename(filePath)}`);
      continue;
    }

    // Skip node_modules and test files
    if (
      filePath.includes("node_modules") ||
      filePath.includes(".test.") ||
      filePath.includes(".spec.")
    ) {
      continue;
    }

    // Only process files matching our globs
    const relativePath = path.relative(process.cwd(), filePath);
    const matchesGlob =
      relativePath.includes("types.ts") ||
      relativePath.startsWith("src/types/");
    if (!matchesGlob) {
      continue;
    }

    processedFiles.add(filePath);

    // Extract interfaces
    const interfaces = sourceFile.getInterfaces();
    for (const interfaceDecl of interfaces) {
      const typeInfo = extractFromInterface(interfaceDecl, filePath);
      types.push(typeInfo);
    }

    // Extract type aliases
    const typeAliases = sourceFile.getTypeAliases();
    for (const typeAlias of typeAliases) {
      const typeInfo = extractFromTypeAlias(typeAlias, filePath);
      types.push(typeInfo);
    }
  }

  // Calculate statistics
  const interfaceCount = types.filter((t) => t.kind === "interface").length;
  const typeAliasCount = types.filter((t) => t.kind === "type_alias").length;
  const zodDerivedCount = types.filter((t) => t.derivedFrom !== undefined).length;
  const exportedCount = types.filter((t) => t.isExported).length;
  const complexCount = types.filter((t) => t.isComplex).length;

  const envelope = createEnvelope(
    "scripts/discover/extractors/types.ts",
    SOURCE_GLOBS,
    Array.from(processedFiles),
    {
      total_items: types.length,
      interfaces: interfaceCount,
      type_aliases: typeAliasCount,
      zod_derived: zodDerivedCount,
      exported: exportedCount,
      complex: complexCount,
    },
    { types }
  );

  writeDiscoveryFile("types-inventory.json", envelope);

  console.log(`  ‚úì Found ${types.length} TypeScript types`);
  console.log(`    - ${interfaceCount} interfaces`);
  console.log(`    - ${typeAliasCount} type aliases`);
  console.log(`    - ${zodDerivedCount} derived from Zod schemas`);
  console.log(`    - ${exportedCount} exported`);
}

// Direct execution support
if (import.meta.url === `file://${process.argv[1]}`) {
  extractTypes().catch((error) => {
    console.error("‚ùå Error extracting types:", error);
    process.exit(1);
  });
}
