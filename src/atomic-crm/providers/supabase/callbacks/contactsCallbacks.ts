/**
 * Contacts Resource Lifecycle Callbacks
 *
 * Resource-specific logic for contacts using React Admin's withLifecycleCallbacks pattern.
 * Uses the createResourceCallbacks factory for standard soft-delete behavior.
 *
 * Key behaviors:
 * 1. Soft delete - Sets deleted_at instead of hard delete
 * 2. JSONB normalization - Ensures email/phone/tags are always arrays
 * 3. Name field computation - Combines first_name + last_name → name (required by DB NOT NULL constraint)
 * 4. Filter cleaning - Adds soft delete filter by default
 * 5. Data transformation - Strips computed fields before save
 * 6. Search transformation - Transforms q filter into ILIKE search on name fields
 *
 * Engineering Constitution: Resource-specific logic extracted for single responsibility
 */

import type { RaRecord, GetListParams, DataProvider } from "ra-core";
import { createResourceCallbacks, type ResourceCallbacks } from "./createResourceCallbacks";
import { normalizeJsonbArrays, createQToIlikeTransformer } from "./commonTransforms";

/**
 * Computed fields that should be stripped before saving to database
 * These are generated by contacts_summary view or computed in the frontend
 */
export const COMPUTED_FIELDS = [
  "full_name",
  "organization_name",
  "primary_organization_name",
  "total_opportunities",
  "last_activity_date",
  // From contacts_summary view aggregations
  "nb_notes",
  "nb_tasks",
  "nb_activities",
  "company_name", // Alias for organization_name in view
] as const;

/**
 * JSONB array fields that need normalization
 * Database may return null/undefined but frontend expects arrays
 * @deprecated Import from commonTransforms instead
 */
export const JSONB_ARRAY_FIELDS = ["email", "phone", "tags"] as const;

/**
 * Fields to search when q filter is provided
 * These fields will be searched with ILIKE for partial matching
 * Only text fields are included - JSONB fields (email, phone) require different operators
 */
export const CONTACTS_SEARCH_FIELDS = ["name", "first_name", "last_name"] as const;

/**
 * Re-export normalizeJsonbArrays from commonTransforms for backward compatibility
 * @deprecated Import from commonTransforms instead
 */
export { normalizeJsonbArrays } from "./commonTransforms";

/**
 * Transform q filter into ILIKE search on contact name fields
 *
 * Matches the unified data provider's search behavior by transforming a simple
 * `q` filter into an `@or` filter with ILIKE conditions on each searchable field.
 *
 * @param params - GetListParams containing the filter with q
 * @returns GetListParams with q transformed to @or ILIKE filters
 *
 * @example
 * ```typescript
 * // Input filter:
 * { q: "john", status: "active" }
 *
 * // Output filter:
 * {
 *   status: "active",
 *   "@or": {
 *     "name@ilike": "%john%",
 *     "first_name@ilike": "%john%",
 *     "last_name@ilike": "%john%",
 *     "email@ilike": "%john%"
 *   }
 * }
 * ```
 */
export function transformQToIlikeSearch(params: GetListParams): GetListParams {
  const { q, ...filterWithoutQ } = params.filter || {};

  // If no q filter, return params unchanged
  if (!q || typeof q !== "string") {
    return params;
  }

  // Wrap search term with wildcards for partial matching
  const searchTerm = `%${q}%`;

  // Build @or filter with ILIKE conditions for each searchable field
  const orFilter = CONTACTS_SEARCH_FIELDS.reduce(
    (acc, field) => ({
      ...acc,
      [`${field}@ilike`]: searchTerm,
    }),
    {} as Record<string, string>
  );

  return {
    ...params,
    filter: {
      ...filterWithoutQ,
      "@or": orFilter,
    },
  };
}

/**
 * Compute name field from first_name and last_name
 *
 * Required by database NOT NULL constraint on contacts.name.
 * The database schema requires a name field, but the UI form captures
 * first_name and last_name separately for better UX.
 *
 * @param data - Contact data (partial for updates, full for creates)
 * @returns Data with computed name field
 *
 * @example
 * ```typescript
 * computeNameField({ first_name: "John", last_name: "Doe" })
 * // Returns: { first_name: "John", last_name: "Doe", name: "John Doe" }
 *
 * computeNameField({ first_name: "John" })
 * // Returns: { first_name: "John", name: "John" }
 *
 * computeNameField({ last_name: "Doe" })
 * // Returns: { last_name: "Doe", name: "Doe" }
 * ```
 */
export function computeNameField(data: Partial<RaRecord>): Partial<RaRecord> {
  // Only compute if first_name or last_name is present in the data
  // This allows partial updates that don't touch these fields to pass through
  if (data.first_name !== undefined || data.last_name !== undefined) {
    const firstName = data.first_name || "";
    const lastName = data.last_name || "";
    return {
      ...data,
      name: `${firstName} ${lastName}`.trim(),
    };
  }
  return data;
}

/**
 * Base callbacks from factory (soft delete, computed fields, transforms)
 * We extract this so we can override beforeGetList with search support
 */
const baseCallbacks = createResourceCallbacks({
  resource: "contacts",
  supportsSoftDelete: true,
  computedFields: COMPUTED_FIELDS,
  afterReadTransform: normalizeJsonbArrays,
  writeTransforms: [computeNameField],
});

/**
 * Custom beforeGetList that chains:
 * 1. q filter → ILIKE search transformation
 * 2. Soft delete filter (from base callbacks)
 *
 * This matches the unified data provider's search behavior while preserving
 * the factory's soft-delete filtering.
 */
async function contactsBeforeGetList(
  params: GetListParams,
  dataProvider: DataProvider
): Promise<GetListParams> {
  // Step 1: Transform q filter to ILIKE search (removes q from filter)
  const searchTransformedParams = transformQToIlikeSearch(params);

  // Step 2: Apply soft delete filter from base callbacks
  // The base callback will add deleted_at@is: null unless includeDeleted is true
  if (baseCallbacks.beforeGetList) {
    return baseCallbacks.beforeGetList(searchTransformedParams, dataProvider);
  }

  return searchTransformedParams;
}

/**
 * Contacts lifecycle callbacks for React Admin withLifecycleCallbacks
 *
 * Usage:
 * ```typescript
 * import { withLifecycleCallbacks } from 'react-admin';
 * import { contactsCallbacks } from './callbacks/contactsCallbacks';
 *
 * const dataProvider = withLifecycleCallbacks(baseProvider, [
 *   contactsCallbacks,
 * ]);
 * ```
 */
export const contactsCallbacks: ResourceCallbacks = {
  ...baseCallbacks,
  beforeGetList: contactsBeforeGetList,
};

/**
 * Export stripComputedFields for backward compatibility with tests
 * The factory handles this internally, but tests may import it directly
 */
export function stripComputedFields(data: Partial<RaRecord>): Partial<RaRecord> {
  const cleaned = { ...data };
  for (const field of COMPUTED_FIELDS) {
    delete cleaned[field];
  }
  return cleaned;
}
