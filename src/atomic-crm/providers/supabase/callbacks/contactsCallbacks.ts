/**
 * Contacts Resource Lifecycle Callbacks
 *
 * Resource-specific logic for contacts using React Admin's withLifecycleCallbacks pattern.
 * Uses the createResourceCallbacks factory with custom cascade delete.
 *
 * Key behaviors:
 * 1. CASCADE SOFT DELETE - FIX [WF-C01]: Uses RPC to archive contact AND related records
 * 2. JSONB normalization - Ensures email/phone/tags are always arrays
 * 3. Name field computation - Combines first_name + last_name → name (required by DB NOT NULL constraint)
 * 4. Filter cleaning - Adds soft delete filter by default
 * 5. Data transformation - Strips computed fields before save
 * 6. Search transformation - Transforms q filter into ILIKE search on name fields
 *
 * WHY CASCADE DELETE VIA RPC:
 * --------------------------
 * Standard soft delete only sets `deleted_at` on ONE record. Contacts have related data
 * that must be archived atomically:
 * - activities (calls, emails, meetings linked to contact)
 * - tasks (assigned to contact)
 * - contact_notes
 * - interaction_participants
 * - opportunity_contacts (junction table)
 *
 * The `archive_contact_with_relations` RPC handles this in a single transaction.
 *
 * Engineering Constitution: Resource-specific logic extracted for single responsibility
 */

import type { RaRecord, GetListParams, DataProvider, DeleteParams } from "ra-core";
import { createResourceCallbacks, type ResourceCallbacks } from "./createResourceCallbacks";
import { normalizeJsonbArrays, createQToIlikeTransformer } from "./commonTransforms";
import { supabase } from "../supabase";
import { collectContactFilePaths, deleteStorageFiles } from "../utils/storageCleanup";
import { logger } from "@/lib/logger";

/**
 * Computed fields that should be stripped before saving to database
 * These are generated by contacts_summary view or computed in the frontend
 */
export const COMPUTED_FIELDS = [
  "full_name",
  "organization_name",
  "primary_organization_name",
  "total_opportunities",
  "last_activity_date",
  // From contacts_summary view aggregations
  "nb_notes",
  "nb_tasks",
  "nb_activities",
  "company_name", // Alias for organization_name in view
] as const;

/**
 * JSONB array fields that need normalization
 * Database may return null/undefined but frontend expects arrays
 * @deprecated Import from commonTransforms instead
 */
export const JSONB_ARRAY_FIELDS = ["email", "phone", "tags"] as const;

/**
 * Fields to search when q filter is provided
 * These fields will be searched with ILIKE for partial matching
 * Only text fields are included - JSONB fields (email, phone) require different operators
 */
export const CONTACTS_SEARCH_FIELDS = ["name", "first_name", "last_name"] as const;

/**
 * Re-export normalizeJsonbArrays from commonTransforms for backward compatibility
 * @deprecated Import from commonTransforms instead
 */
export { normalizeJsonbArrays } from "./commonTransforms";

/**
 * Transform q filter into ILIKE search on contact name fields
 * Uses shared factory from commonTransforms for DRY compliance
 *
 * @see createQToIlikeTransformer in commonTransforms.ts
 */
export const transformQToIlikeSearch = createQToIlikeTransformer({
  searchFields: CONTACTS_SEARCH_FIELDS,
});

/**
 * Compute name field from first_name and last_name
 *
 * Required by database NOT NULL constraint on contacts.name.
 * The database schema requires a name field, but the UI form captures
 * first_name and last_name separately for better UX.
 *
 * FIX [DATA-001]: Prevents contacts displaying email as name by:
 * 1. Always computing name from first_name/last_name when available
 * 2. Falling back to "Unknown Contact" when no valid name can be computed
 * 3. Logging warning for data quality issues (fail-fast principle)
 *
 * @param data - Contact data (partial for updates, full for creates)
 * @returns Data with computed name field
 *
 * @example
 * ```typescript
 * computeNameField({ first_name: "John", last_name: "Doe" })
 * // Returns: { first_name: "John", last_name: "Doe", name: "John Doe" }
 *
 * computeNameField({ first_name: "John" })
 * // Returns: { first_name: "John", name: "John" }
 *
 * computeNameField({ last_name: "Doe" })
 * // Returns: { last_name: "Doe", name: "Doe" }
 *
 * computeNameField({ email: [{ value: "john@example.com" }] })
 * // Returns: { ..., name: "Unknown Contact" } (with warning logged)
 * ```
 */
export function computeNameField(data: RaRecord): RaRecord {
  const firstName = typeof data.first_name === "string" ? data.first_name.trim() : "";
  const lastName = typeof data.last_name === "string" ? data.last_name.trim() : "";

  // Compute name from first_name and last_name if either is present
  if (firstName || lastName) {
    return {
      ...data,
      name: `${firstName} ${lastName}`.trim(),
    };
  }

  // For partial updates that don't include first_name/last_name, preserve existing name
  if (data.first_name === undefined && data.last_name === undefined && data.name) {
    return data;
  }

  // For creates or when name is missing/empty: use fallback
  // FIX [DATA-001]: Prevent empty or email-like names in database
  if (!data.name || (typeof data.name === "string" && data.name.trim() === "")) {
    logger.warn(
      "Contact created without proper name - using fallback. This indicates a data quality issue.",
      {
        feature: "ContactsCallbacks",
        contactId: data.id,
        firstName: data.first_name,
        lastName: data.last_name,
      }
    );
    return {
      ...data,
      name: "Unknown Contact",
    };
  }

  return data;
}

// ============================================================================
// CUSTOM CALLBACKS (Override factory defaults)
// ============================================================================

/**
 * Custom beforeDelete: Use archive RPC for cascading soft delete
 *
 * FIX [WF-C01]: Standard soft delete only sets `deleted_at` on ONE record.
 * Contacts have related data that must be archived atomically:
 * - activities, tasks, contact_notes, interaction_participants, opportunity_contacts
 *
 * FIX [SF-C10]: Clean up storage files after archive.
 * Files in activities.attachments and contact_notes.attachments are deleted.
 *
 * The `archive_contact_with_relations` RPC handles this in a single transaction.
 */
async function contactsBeforeDelete(
  params: DeleteParams,
  _dataProvider: DataProvider
): Promise<DeleteParams & { meta?: { skipDelete?: boolean } }> {
  // Validate ID before RPC call (fail-fast)
  const numericId = Number(params.id);
  if (!Number.isInteger(numericId) || numericId <= 0) {
    throw new Error(`Invalid contact ID: ${params.id}`);
  }

  // FIX [SF-C10]: Collect file paths BEFORE archiving (records will be soft-deleted)
  const filePaths = await collectContactFilePaths(numericId);

  // Use Supabase client directly - bypasses DataProvider abstraction
  // This is the React Admin recommended pattern for lifecycle callbacks
  const { error: rpcError } = await supabase.rpc("archive_contact_with_relations", {
    contact_id: numericId,
  });

  if (rpcError) {
    throw new Error(`Archive contact failed: ${rpcError.message}`);
  }

  // FIX [SF-C10]: Storage cleanup is intentionally fire-and-forget
  // INTENTIONAL SILENT: Archive operation already succeeded; storage cleanup failure
  // should not block user or cause rollback. Orphaned files are acceptable
  // technical debt that can be cleaned up via scheduled job.
  if (filePaths.length > 0) {
    try {
      await deleteStorageFiles(filePaths);
    } catch (error: unknown) {
      // Structured logging with context for debugging (non-blocking)
      logger.warn("Storage cleanup failed after contact archive", {
        feature: "ContactsCallbacks",
        contactId: numericId,
        fileCount: filePaths.length,
        files: filePaths.slice(0, 5), // First 5 for debugging, avoid huge logs
        errorMessage: error instanceof Error ? error.message : String(error),
        operation: "contactsBeforeDelete",
        note: "Archive succeeded - orphaned files can be cleaned up later",
      });
    }
  }

  // Return params with meta flag to skip actual delete (RPC already archived)
  return {
    ...params,
    meta: { ...params.meta, skipDelete: true },
  };
}

/**
 * Base callbacks from factory (computed fields, transforms)
 * We DON'T use soft delete from factory because we need custom RPC cascade delete
 */
const baseCallbacks = createResourceCallbacks({
  resource: "contacts",
  supportsSoftDelete: false, // FIX [WF-C01]: We handle soft delete via custom RPC
  computedFields: COMPUTED_FIELDS,
  afterReadTransform: normalizeJsonbArrays,
  writeTransforms: [computeNameField],
});

/**
 * Custom beforeGetList that chains:
 * 1. q filter → ILIKE search transformation
 * 2. Soft delete filter (manual since we disabled factory soft delete)
 *
 * This matches the unified data provider's search behavior while applying
 * soft-delete filtering.
 */
async function contactsBeforeGetList(
  params: GetListParams,
  _dataProvider: DataProvider
): Promise<GetListParams> {
  // Step 1: Transform q filter to ILIKE search (removes q from filter)
  const searchTransformedParams = transformQToIlikeSearch(params);

  // Step 2: Apply soft delete filter manually (since factory soft delete is disabled)
  const { includeDeleted, ...otherFilters } = searchTransformedParams.filter || {};
  const softDeleteFilter = includeDeleted ? {} : { "deleted_at@is": null };

  return {
    ...searchTransformedParams,
    filter: {
      ...otherFilters,
      ...softDeleteFilter,
    },
  };
}

/**
 * Contacts lifecycle callbacks for React Admin withLifecycleCallbacks
 *
 * FIX [WF-C01]: Uses custom beforeDelete that calls archive_contact_with_relations RPC
 * for atomic cascade soft delete of contact and all related records.
 *
 * Usage:
 * ```typescript
 * import { withLifecycleCallbacks } from 'react-admin';
 * import { contactsCallbacks } from './callbacks/contactsCallbacks';
 *
 * const dataProvider = withLifecycleCallbacks(baseProvider, [
 *   contactsCallbacks,
 * ]);
 * ```
 */
export const contactsCallbacks: ResourceCallbacks = {
  ...baseCallbacks,
  beforeDelete: contactsBeforeDelete, // FIX [WF-C01]: Cascade via RPC
  beforeGetList: contactsBeforeGetList,
};

/**
 * Export stripComputedFields for backward compatibility with tests
 * The factory handles this internally, but tests may import it directly
 */
export function stripComputedFields(data: Partial<RaRecord>): Partial<RaRecord> {
  const cleaned = { ...data };
  for (const field of COMPUTED_FIELDS) {
    delete cleaned[field];
  }
  return cleaned;
}
