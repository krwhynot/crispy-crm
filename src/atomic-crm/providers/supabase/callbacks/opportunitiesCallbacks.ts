/**
 * Opportunities Resource Lifecycle Callbacks
 *
 * Resource-specific logic for opportunities using React Admin's withLifecycleCallbacks pattern.
 * Uses createResourceCallbacks factory with custom overrides for complex behaviors.
 *
 * WHY OPPORTUNITIES IS MORE COMPLEX:
 * ----------------------------------
 * Unlike simpler resources (contacts, sales), opportunities requires custom overrides for:
 *
 * 1. CASCADE DELETE VIA RPC:
 *    Standard soft delete sets `deleted_at` on ONE record. Opportunities needs to archive
 *    the opportunity AND all related records (activities, notes, tasks, participants) atomically.
 *    This is done via `archive_opportunity_with_relations` PostgreSQL RPC function.
 *
 * 2. PRODUCTS SYNC VIA SERVICE:
 *    The UI sends `products_to_sync` (array of product IDs to link) which is handled by
 *    OpportunitiesService.createWithProducts/updateWithProducts in the handler layer.
 *    This virtual field must be stripped before database save.
 *
 * 3. STAGE-ONLY UPDATES (KANBAN):
 *    When dragging cards on Kanban board, only `stage` is sent. If `contact_ids` is empty
 *    from previousData merge, it would fail Zod validation. We detect stage-only updates
 *    and strip empty contact_ids to avoid validation errors.
 *
 * Engineering Constitution: Resource-specific logic extracted for single responsibility
 * Pattern: Factory + custom overrides (hybrid approach for complex resources)
 */

import type { RaRecord, GetListParams, DataProvider, DeleteParams, UpdateParams } from "ra-core";
import { createResourceCallbacks, type ResourceCallbacks } from "./createResourceCallbacks";
import type { Opportunity } from "../../../types";
import { supabase } from "../supabase";
import { logger } from "@/lib/logger";

/**
 * Type-safe computed fields that exist on the Opportunity type
 * These are generated by views, aggregations, triggers, or are system-managed
 * Compiler will error if a field doesn't exist on Opportunity
 *
 * Source: opportunities_summary view + database triggers
 * Updated: 2025-12-20 to include all fields from view that cause validation errors
 *
 * NOTE: These fields are stripped from BOTH create and update operations.
 * For UPDATE-only stripping, see UPDATE_ONLY_STRIP_FIELDS below.
 */
const TYPED_COMPUTED_FIELDS = [
  // Joined org names (from view JOINs)
  "principal_organization_name",
  "customer_organization_name",
  "distributor_organization_name",
  "primary_contact_name",
  // Computed aggregations (calculated in view)
  "days_in_stage",
  "days_since_last_activity",
  "pending_task_count",
  "overdue_task_count",
  "nb_interactions",
  "last_interaction_date",
  // Next task computed fields (from tasks subquery)
  "next_task_id",
  "next_task_title",
  "next_task_due_date",
  "next_task_priority",
  // System/trigger fields (set automatically by PostgreSQL)
  "stage_changed_at",
  "created_by",
  // Internal state fields (managed by system, not directly editable)
  "status",
  "actual_close_date",
  "founding_interaction_id",
  "stage_manual",
  "status_manual",
  "competition",
  // NOTE: opportunity_owner_id removed - it's in UPDATE_ONLY_STRIP_FIELDS
  // because CREATE operations need to pass it to the database
] as const satisfies readonly (keyof Opportunity)[];

/**
 * Fields that should ONLY be stripped from UPDATE operations, NOT create.
 *
 * FIX [WF-E2E-001]: opportunity_owner_id must be preserved during CREATE
 * so the database can set the owner. The trigger `set_opportunity_owner_defaults`
 * expects this field or falls back to current_sales_id(). If we strip it
 * during CREATE and auth context isn't properly set, the trigger fails with:
 * "Cannot determine opportunity owner. User may not have a sales record."
 *
 * For UPDATE operations, this field should be stripped because:
 * - updateOpportunitySchema does not include it (strictObject validation)
 * - Ownership changes should go through dedicated reassignment flows
 */
const UPDATE_ONLY_STRIP_FIELDS = [
  "opportunity_owner_id",
] as const satisfies readonly (keyof Opportunity)[];

/**
 * View-only fields that exist in database views but NOT on the Opportunity type
 * These are computed by SQL views and should be stripped before saving
 */
const VIEW_ONLY_FIELDS = [
  "search_tsv",
  "updated_by",
  "index",
  "total_value",
  "participant_count",
  "contact_count",
  "product_count",
  "last_activity_date",
] as const;

/**
 * Combined computed fields for stripping - includes both typed and view-only fields
 */
const COMPUTED_FIELDS = [...TYPED_COMPUTED_FIELDS, ...VIEW_ONLY_FIELDS] as const;

/**
 * Virtual fields that should be stripped before database save
 * These are UI-only fields not present in the database schema
 *
 * NOTE: products_to_sync is NOT stripped here because:
 * 1. The handler layer (opportunitiesHandler.ts) needs to process it first
 * 2. Handler extracts products_to_sync and delegates to OpportunitiesService
 * 3. The service handles the atomic product sync and returns clean data
 * 4. By the time data reaches baseProvider.create/update, products_to_sync is already handled
 *
 * IMPORTANT: products_to_sync was previously incorrectly listed here, causing test failures.
 * The handler composition means beforeSave runs BEFORE the handler sees the data, so if
 * we strip products_to_sync here, the handler never gets a chance to delegate to the service.
 */
const VIRTUAL_FIELDS = [
  "products", // Legacy field name, may come from some forms
  // products_to_sync intentionally NOT included - see NOTE above
] as const;

/**
 * Default values for opportunity create
 * Used to ensure validation passes when fields are missing
 *
 * FIX [WF-E2E-001]: REMOVED contact_ids from defaults.
 * Quick creates should NOT have contact_ids set at all (undefined).
 * The createOpportunitySchema.refine() allows undefined contact_ids
 * for quick creates but rejects empty arrays [] for full creates.
 * Setting contact_ids: [] here was causing quick creates to fail validation.
 */
const CREATE_DEFAULTS = {} as const;

/**
 * Strip computed and virtual fields that shouldn't be sent to database
 *
 * @param data - The data being saved
 * @param isUpdate - Whether this is an UPDATE operation (vs CREATE)
 * @returns Data without computed/virtual fields
 *
 * FIX [WF-E2E-001]: Added isUpdate parameter to conditionally strip
 * UPDATE_ONLY_STRIP_FIELDS (like opportunity_owner_id) only during updates.
 * CREATE operations preserve these fields so the database can set them.
 */
function stripComputedFields(data: Partial<RaRecord>, isUpdate = false): Partial<RaRecord> {
  const cleaned = { ...data };

  // Strip computed fields (from views/aggregations)
  for (const field of COMPUTED_FIELDS) {
    delete cleaned[field];
  }

  // Strip virtual fields (UI-only, not in database schema)
  for (const field of VIRTUAL_FIELDS) {
    delete cleaned[field];
  }

  // FIX [WF-E2E-001]: Only strip UPDATE_ONLY_STRIP_FIELDS during update operations
  // CREATE operations preserve these fields (e.g., opportunity_owner_id)
  if (isUpdate) {
    for (const field of UPDATE_ONLY_STRIP_FIELDS) {
      delete cleaned[field];
    }
  }

  return cleaned;
}

/**
 * Merge default values for create operation
 * Ensures required fields have values for validation
 *
 * @param data - The data being created
 * @returns Data with defaults merged
 */
function mergeCreateDefaults(data: Partial<RaRecord>): Partial<RaRecord> {
  return {
    ...CREATE_DEFAULTS,
    ...data,
  };
}

// ============================================================================
// CUSTOM CALLBACKS (Override factory defaults)
// ============================================================================

/**
 * Custom beforeDelete: Use archive RPC for cascading soft delete
 *
 * WHY CUSTOM: Standard soft delete only sets `deleted_at` on ONE record.
 * Opportunities have related data that must be archived atomically:
 * - activities (calls, emails, meetings)
 * - opportunityNotes
 * - opportunity_participants (junction table)
 * - tasks
 *
 * The `archive_opportunity_with_relations` RPC handles this in a single transaction.
 */
async function opportunitiesBeforeDelete(
  params: DeleteParams,
  dataProvider: DataProvider
): Promise<DeleteParams & { meta?: { skipDelete?: boolean } }> {
  // Validate ID before RPC call (fail-fast)
  const numericId = Number(params.id);
  if (!Number.isInteger(numericId) || numericId <= 0) {
    throw new Error(`Invalid opportunity ID: ${params.id}`);
  }

  // FIX [WF-H2-002]: Log activity before archive (fire-and-forget, backup path)
  // Primary activity logging is in OpportunitiesService.archiveOpportunity().
  // This covers the React Admin DeleteButton path (if used).
  void dataProvider.create("activities", {
    data: {
      activity_type: "interaction",
      type: "note",
      subject: "Opportunity archived",
      description: `Opportunity archived via delete action`,
      activity_date: new Date().toISOString(),
      opportunity_id: numericId,
    },
  }).catch((err: unknown) => {
    const errorMessage = err instanceof Error ? err.message : String(err);
    logger.warn("Activity logging failed during beforeDelete", err instanceof Error ? err : new Error(errorMessage), {
      feature: "opportunities",
      opportunityId: numericId,
    });
  });

  // Use Supabase client directly - bypasses DataProvider abstraction
  // This is the React Admin recommended pattern for lifecycle callbacks
  const { error: rpcError } = await supabase.rpc("archive_opportunity_with_relations", {
    opp_id: numericId,
  });

  if (rpcError) {
    throw new Error(`Archive opportunity failed: ${rpcError.message}`);
  }

  // Return params with meta flag to skip actual delete (RPC already archived)
  return {
    ...params,
    meta: { ...params.meta, skipDelete: true },
  };
}

/**
 * Custom beforeGetList: Apply soft delete filter only
 *
 * NOTE: q filter transformation is handled centrally by applySearchParams() in composedDataProvider.
 * This callback only needs to apply the soft delete filter.
 */
async function opportunitiesBeforeGetList(
  params: GetListParams,
  _dataProvider: DataProvider
): Promise<GetListParams> {
  // Apply soft delete filter (search is handled by applySearchParams in composedDataProvider)
  const { includeDeleted, ...otherFilters } = params.filter || {};
  const softDeleteFilter = includeDeleted ? {} : { "deleted_at@is": null };

  return {
    ...params,
    filter: {
      ...otherFilters,
      ...softDeleteFilter,
    },
  };
}

/**
 * Validate stage transition prerequisites
 *
 * Enforces business rules for stage changes:
 * - closed_won/closed_lost require actual_close_date
 *
 * @param toStage - Target stage
 * @param data - Opportunity data being saved
 * @throws Error if prerequisites not met
 */
function validateStageTransition(toStage: string, data: Partial<RaRecord>): void {
  // Closed stages require actual_close_date
  if (["closed_won", "closed_lost"].includes(toStage) && !data.actual_close_date) {
    throw new Error("Close date required when closing opportunity");
  }
}

/**
 * Custom beforeUpdate: Log stage transitions as activities
 *
 * WHY CUSTOM: When opportunity stage changes, create an audit trail activity
 * to track the transition. This provides visibility into opportunity progression.
 *
 * @param params - Update parameters with data and previousData
 * @param dataProvider - React Admin data provider for creating activity
 * @returns Unchanged params (activity creation is side effect)
 */
async function opportunitiesBeforeUpdate(
  params: UpdateParams,
  dataProvider: DataProvider
): Promise<UpdateParams> {
  const { data, previousData } = params;

  // Check if stage changed
  if (previousData?.stage && data.stage && previousData.stage !== data.stage) {
    // Validate stage transition prerequisites (fail-fast)
    validateStageTransition(data.stage, data);

    try {
      // Log stage transition activity
      await dataProvider.create("activities", {
        data: {
          activity_type: "interaction",
          type: "note",
          subject: `Stage changed: ${previousData.stage} â†’ ${data.stage}`,
          description: `Opportunity stage transitioned from ${previousData.stage} to ${data.stage}`,
          opportunity_id: params.id,
          contact_id: previousData.contact_ids?.[0] || null,
          organization_id:
            previousData.principal_organization_id || previousData.customer_organization_id || null,
          activity_date: new Date().toISOString(),
        },
      });
    } catch (error) {
      // Log but don't block update if activity creation fails
      // Stage update is the primary action, activity is side effect
      logger.warn(
        "Failed to create stage transition activity",
        error instanceof Error ? error : new Error(String(error)),
        {
          feature: "opportunities",
          opportunityId: params.id,
          fromStage: previousData.stage,
          toStage: data.stage,
        }
      );
    }
  }

  return params;
}

/**
 * Custom beforeSave: Strip fields + handle stage-only updates
 *
 * WHY CUSTOM: Beyond standard computed field stripping, opportunities needs:
 * 1. Virtual field stripping (products_to_sync, products)
 * 2. Stage-only update detection for Kanban (strip empty contact_ids)
 * 3. Create defaults merging
 * 4. FIX [WF-E2E-001]: Conditional stripping of UPDATE_ONLY_STRIP_FIELDS
 */
async function opportunitiesBeforeSave(
  data: Partial<RaRecord>,
  _dataProvider: DataProvider,
  _resource: string
): Promise<Partial<RaRecord>> {
  // FIX [WF-E2E-001]: Detect CREATE vs UPDATE
  // - UPDATE: data.id is present (React Admin includes id in data for updates)
  // - CREATE: data.id is undefined/null
  // This determines whether to strip UPDATE_ONLY_STRIP_FIELDS (like opportunity_owner_id)
  const isUpdate = data.id != null;

  // Strip computed fields - conditionally strip UPDATE_ONLY_STRIP_FIELDS for updates
  let processed = stripComputedFields(data, isUpdate);

  // Strip empty contact_ids for stage-only updates (Kanban drag-drop)
  // Detection: stage is present AND this is an update (has id) AND name is NOT present
  // When contact_ids is empty array from previousData merge, strip it to avoid validation error
  const isStageOnlyUpdate = isUpdate && data.stage && !data.name;
  const hasEmptyContactIds = Array.isArray(data.contact_ids) && data.contact_ids.length === 0;

  if (isStageOnlyUpdate && hasEmptyContactIds) {
    delete processed.contact_ids;
  }

  // Merge defaults for create (when no id - indicates create operation)
  if (!isUpdate) {
    processed = mergeCreateDefaults(processed);
  }

  return processed;
}

// ============================================================================
// FACTORY + OVERRIDES (Hybrid Pattern)
// ============================================================================

/**
 * Base callbacks from factory
 * We DON'T use soft delete from factory because we need custom RPC cascade delete
 */
const baseCallbacks = createResourceCallbacks({
  resource: "opportunities",
  supportsSoftDelete: false, // We handle soft delete via custom RPC
  computedFields: [], // We handle in custom beforeSave (includes virtual fields)
  createDefaults: CREATE_DEFAULTS,
});

/**
 * Opportunities lifecycle callbacks for React Admin withLifecycleCallbacks
 *
 * Uses factory pattern with custom overrides for complex behaviors.
 * See module header comment for detailed explanation of WHY overrides are needed.
 *
 * Usage:
 * ```typescript
 * import { withLifecycleCallbacks } from 'react-admin';
 * import { opportunitiesCallbacks } from './callbacks/opportunitiesCallbacks';
 *
 * const dataProvider = withLifecycleCallbacks(baseProvider, [
 *   opportunitiesCallbacks,
 * ]);
 * ```
 */
export const opportunitiesCallbacks: ResourceCallbacks = {
  ...baseCallbacks,
  // Override with custom implementations
  beforeDelete: opportunitiesBeforeDelete,
  beforeGetList: opportunitiesBeforeGetList,
  beforeUpdate: opportunitiesBeforeUpdate,
  beforeSave: opportunitiesBeforeSave,
  // afterRead is inherited from base (no-op since opportunities has no JSONB arrays)
};

/**
 * Export helper functions for testing
 */
export {
  stripComputedFields,
  mergeCreateDefaults,
  COMPUTED_FIELDS,
  TYPED_COMPUTED_FIELDS,
  VIEW_ONLY_FIELDS,
  UPDATE_ONLY_STRIP_FIELDS,
  CREATE_DEFAULTS,
};
