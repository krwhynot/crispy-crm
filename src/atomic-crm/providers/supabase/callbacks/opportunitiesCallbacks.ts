/**
 * Opportunities Resource Lifecycle Callbacks
 *
 * Resource-specific logic for opportunities using React Admin's withLifecycleCallbacks pattern.
 * More complex than contacts/organizations due to:
 * 1. Cascading soft delete via RPC (archive_opportunity_with_relations)
 * 2. Virtual field stripping (products_to_sync is UI-only, handled via OpportunitiesService)
 * 3. Default value merging for create validation
 *
 * Engineering Constitution: Resource-specific logic extracted for single responsibility
 */

import type { RaRecord, GetListParams, DataProvider } from "ra-core";
import { createResourceCallbacks, type ResourceCallbacks } from "./createResourceCallbacks";
import { createQToIlikeTransformer } from "./commonTransforms";
import type { Opportunity } from "../../../types";
import { supabase } from "../supabase";

/**
 * Type-safe computed fields that exist on the Opportunity type
 * These are generated by views, aggregations, triggers, or are system-managed
 * Compiler will error if a field doesn't exist on Opportunity
 *
 * Source: opportunities_summary view + database triggers
 * Updated: 2025-12-20 to include all fields from view that cause validation errors
 */
const TYPED_COMPUTED_FIELDS = [
  // Joined org names (from view JOINs)
  "principal_organization_name",
  "customer_organization_name",
  "distributor_organization_name",
  // Computed aggregations (calculated in view)
  "days_in_stage",
  "days_since_last_activity",
  "pending_task_count",
  "overdue_task_count",
  "nb_interactions",
  "last_interaction_date",
  // Next task computed fields (from tasks subquery)
  "next_task_id",
  "next_task_title",
  "next_task_due_date",
  "next_task_priority",
  // System/trigger fields (set automatically by PostgreSQL)
  "stage_changed_at",
  "created_by",
  // Internal state fields (managed by system, not directly editable)
  "status",
  "actual_close_date",
  "founding_interaction_id",
  "stage_manual",
  "status_manual",
  "competition",
  // Owner/assignment fields (set programmatically, not via edit form)
  // NOTE: Stripped from UPDATE payloads to pass Zod strictObject validation
  // Database has this field but updateOpportunitySchema does not include it
  "opportunity_owner_id",
] as const satisfies readonly (keyof Opportunity)[];

/**
 * View-only fields that exist in database views but NOT on the Opportunity type
 * These are computed by SQL views and should be stripped before saving
 */
const VIEW_ONLY_FIELDS = [
  "search_tsv",
  "updated_by",
  "index",
  "total_value",
  "participant_count",
  "contact_count",
  "product_count",
  "last_activity_date",
] as const;

/**
 * Combined computed fields for stripping - includes both typed and view-only fields
 */
const COMPUTED_FIELDS = [
  ...TYPED_COMPUTED_FIELDS,
  ...VIEW_ONLY_FIELDS,
] as const;

/**
 * Virtual fields that should be stripped before database save
 * These are UI-only fields not present in the database schema
 */
const VIRTUAL_FIELDS = [
  "products_to_sync", // UI field for product sync (handled via RPC in OpportunitiesService)
  "products", // Legacy field name, may come from some forms
] as const;

/**
 * Default values for opportunity create
 * Used to ensure validation passes when fields are missing
 */
const CREATE_DEFAULTS = {
  contact_ids: [] as number[],
} as const;

/**
 * Fields to search when q filter is provided
 * These fields will be searched with ILIKE for partial matching
 */
export const OPPORTUNITIES_SEARCH_FIELDS = ["name", "description"] as const;

/**
 * Transform q filter into ILIKE search on opportunity fields
 *
 * Matches the unified data provider's search behavior by transforming a simple
 * `q` filter into an `@or` filter with ILIKE conditions on each searchable field.
 *
 * @param params - GetListParams containing the filter with q
 * @returns GetListParams with q transformed to @or ILIKE filters
 *
 * @example
 * ```typescript
 * // Input filter:
 * { q: "enterprise", stage: "negotiation" }
 *
 * // Output filter:
 * {
 *   stage: "negotiation",
 *   "@or": {
 *     "name@ilike": "%enterprise%",
 *     "description@ilike": "%enterprise%"
 *   }
 * }
 * ```
 */
export function transformQToIlikeSearch(params: GetListParams): GetListParams {
  const { q, ...filterWithoutQ } = params.filter || {};

  // If no q filter, return params unchanged
  if (!q || typeof q !== "string") {
    return params;
  }

  // Wrap search term with wildcards for partial matching
  const searchTerm = `%${q}%`;

  // Build @or filter with ILIKE conditions for each searchable field
  const orFilter = OPPORTUNITIES_SEARCH_FIELDS.reduce(
    (acc, field) => ({
      ...acc,
      [`${field}@ilike`]: searchTerm,
    }),
    {} as Record<string, string>
  );

  return {
    ...params,
    filter: {
      ...filterWithoutQ,
      "@or": orFilter,
    },
  };
}

/**
 * Strip computed and virtual fields that shouldn't be sent to database
 *
 * @param data - The data being saved
 * @returns Data without computed/virtual fields
 */
function stripComputedFields(data: Partial<RaRecord>): Partial<RaRecord> {
  const cleaned = { ...data };

  // Strip computed fields (from views/aggregations)
  for (const field of COMPUTED_FIELDS) {
    delete cleaned[field];
  }

  // Strip virtual fields (UI-only, not in database schema)
  for (const field of VIRTUAL_FIELDS) {
    delete cleaned[field];
  }

  return cleaned;
}

/**
 * Merge default values for create operation
 * Ensures required fields have values for validation
 *
 * @param data - The data being created
 * @returns Data with defaults merged
 */
function mergeCreateDefaults(data: Partial<RaRecord>): Partial<RaRecord> {
  return {
    ...CREATE_DEFAULTS,
    ...data,
  };
}

/**
 * Opportunities lifecycle callbacks for React Admin withLifecycleCallbacks
 *
 * Usage:
 * ```typescript
 * import { withLifecycleCallbacks } from 'react-admin';
 * import { opportunitiesCallbacks } from './callbacks/opportunitiesCallbacks';
 *
 * const dataProvider = withLifecycleCallbacks(baseProvider, [
 *   opportunitiesCallbacks,
 * ]);
 * ```
 */
export const opportunitiesCallbacks: ResourceCallbacks = {
  resource: "opportunities",

  /**
   * Use archive RPC for cascading soft delete
   * This archives the opportunity AND all related records:
   * - activities
   * - opportunityNotes
   * - opportunity_participants
   * - tasks
   */
  beforeDelete: async (params) => {
    console.log(
      "ðŸŸ¡ [opportunitiesCallbacks.beforeDelete] ENTRY - id:",
      params.id,
      "type:",
      typeof params.id
    );

    // Validate ID before RPC call (fail-fast)
    const numericId = Number(params.id);
    if (!Number.isInteger(numericId) || numericId <= 0) {
      throw new Error(`Invalid opportunity ID: ${params.id}`);
    }

    console.log(
      "ðŸŸ¡ [opportunitiesCallbacks.beforeDelete] Calling supabase.rpc with opp_id:",
      numericId
    );

    // Use Supabase client directly - bypasses DataProvider abstraction
    // This is the React Admin recommended pattern for lifecycle callbacks
    const { error: rpcError } = await supabase.rpc("archive_opportunity_with_relations", {
      opp_id: numericId,
    });

    if (rpcError) {
      console.error("ðŸŸ¡ [opportunitiesCallbacks.beforeDelete] RPC FAILED:", rpcError);
      throw new Error(`Archive opportunity failed: ${rpcError.message}`);
    }

    console.log("ðŸŸ¡ [opportunitiesCallbacks.beforeDelete] RPC SUCCESS - returning skipDelete");

    // Return params with meta flag to skip actual delete (RPC already archived)
    return {
      ...params,
      meta: { ...params.meta, skipDelete: true },
    };
  },

  /**
   * Normalize data after reading from database
   * Opportunities don't have JSONB arrays, but we keep this for consistency
   */
  afterRead: async (record, _dataProvider) => {
    // No transformation needed - dates and values are already properly formatted
    return record;
  },

  /**
   * Add soft delete filter and transform q filter before getList
   * 1. Transform q filter â†’ ILIKE search
   * 2. Exclude soft-deleted records by default
   */
  beforeGetList: async (params, _dataProvider) => {
    // Step 1: Transform q filter to ILIKE search (removes q from filter)
    const searchTransformedParams = transformQToIlikeSearch(params);

    // Step 2: Apply soft delete filter
    const { includeDeleted, ...otherFilters } = searchTransformedParams.filter || {};
    const softDeleteFilter = includeDeleted ? {} : { "deleted_at@is": null };

    return {
      ...searchTransformedParams,
      filter: {
        ...otherFilters,
        ...softDeleteFilter,
      },
    };
  },

  /**
   * Process data before save (create/update)
   * - Strip computed fields (from views/aggregations)
   * - Strip virtual fields (products_to_sync, products - UI-only fields)
   * - Strip contact_ids for stage-only updates (Kanban drag-drop)
   * - Merge defaults for create
   */
  beforeSave: async (data, _dataProvider, _resource) => {
    // Strip computed fields first
    let processed = stripComputedFields(data);

    // Strip empty contact_ids for stage-only updates (Kanban drag-drop)
    // NOTE: data.id is NOT available in beforeSave - id is passed separately as params.id
    // Detection: stage is present, name is NOT present (name is required for create/full edit)
    // When contact_ids is empty array from previousData merge, strip it to avoid validation error
    const isStageOnlyUpdate = data.stage && !data.name;
    const hasEmptyContactIds = Array.isArray(data.contact_ids) && data.contact_ids.length === 0;

    // Debug logging - remove after verification
    console.log("[beforeSave] Processing opportunity:", {
      incomingData: { stage: data.stage, name: data.name, contact_ids: data.contact_ids },
      isStageOnlyUpdate,
      hasEmptyContactIds,
      willStripContactIds: isStageOnlyUpdate && hasEmptyContactIds,
    });

    if (isStageOnlyUpdate && hasEmptyContactIds) {
      delete processed.contact_ids;
    }

    // Merge defaults for create (when no required fields present - indicates create operation)
    // Note: We check for name since it's required for create, not data.id (unavailable here)
    if (!data.name) {
      // Only merge defaults if this looks like a create (no id means create in validation layer)
      // But for stage-only updates, skip defaults
      if (!isStageOnlyUpdate) {
        processed = mergeCreateDefaults(processed);
      }
    }

    console.log("[beforeSave] Final processed data:", {
      stage: processed.stage,
      keys: Object.keys(processed),
    });

    return processed;
  },
};

/**
 * Export helper functions for testing
 */
export {
  stripComputedFields,
  mergeCreateDefaults,
  COMPUTED_FIELDS,
  TYPED_COMPUTED_FIELDS,
  VIEW_ONLY_FIELDS,
  CREATE_DEFAULTS,
};
