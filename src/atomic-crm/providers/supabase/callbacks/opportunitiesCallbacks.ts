/**
 * Opportunities Resource Lifecycle Callbacks
 *
 * Resource-specific logic for opportunities using React Admin's withLifecycleCallbacks pattern.
 * Uses createResourceCallbacks factory with custom overrides for complex behaviors.
 *
 * WHY OPPORTUNITIES IS MORE COMPLEX:
 * ----------------------------------
 * Unlike simpler resources (contacts, sales), opportunities requires custom overrides for:
 *
 * 1. CASCADE DELETE VIA RPC:
 *    Standard soft delete sets `deleted_at` on ONE record. Opportunities needs to archive
 *    the opportunity AND all related records (activities, notes, tasks, participants) atomically.
 *    This is done via `archive_opportunity_with_relations` PostgreSQL RPC function.
 *
 * 2. PRODUCTS SYNC VIA SERVICE:
 *    The UI sends `products_to_sync` (array of product IDs to link) which is handled by
 *    OpportunitiesService.createWithProducts/updateWithProducts in the handler layer.
 *    This virtual field must be stripped before database save.
 *
 * 3. STAGE-ONLY UPDATES (KANBAN):
 *    When dragging cards on Kanban board, only `stage` is sent. If `contact_ids` is empty
 *    from previousData merge, it would fail Zod validation. We detect stage-only updates
 *    and strip empty contact_ids to avoid validation errors.
 *
 * Engineering Constitution: Resource-specific logic extracted for single responsibility
 * Pattern: Factory + custom overrides (hybrid approach for complex resources)
 */

import type { RaRecord, GetListParams, DataProvider, DeleteParams } from "ra-core";
import { createResourceCallbacks, type ResourceCallbacks } from "./createResourceCallbacks";
import type { Opportunity } from "../../../types";
import { supabase } from "../supabase";

/**
 * Type-safe computed fields that exist on the Opportunity type
 * These are generated by views, aggregations, triggers, or are system-managed
 * Compiler will error if a field doesn't exist on Opportunity
 *
 * Source: opportunities_summary view + database triggers
 * Updated: 2025-12-20 to include all fields from view that cause validation errors
 */
const TYPED_COMPUTED_FIELDS = [
  // Joined org names (from view JOINs)
  "principal_organization_name",
  "customer_organization_name",
  "distributor_organization_name",
  // Computed aggregations (calculated in view)
  "days_in_stage",
  "days_since_last_activity",
  "pending_task_count",
  "overdue_task_count",
  "nb_interactions",
  "last_interaction_date",
  // Next task computed fields (from tasks subquery)
  "next_task_id",
  "next_task_title",
  "next_task_due_date",
  "next_task_priority",
  // System/trigger fields (set automatically by PostgreSQL)
  "stage_changed_at",
  "created_by",
  // Internal state fields (managed by system, not directly editable)
  "status",
  "actual_close_date",
  "founding_interaction_id",
  "stage_manual",
  "status_manual",
  "competition",
  // Owner/assignment fields (set programmatically, not via edit form)
  // NOTE: Stripped from UPDATE payloads to pass Zod strictObject validation
  // Database has this field but updateOpportunitySchema does not include it
  "opportunity_owner_id",
] as const satisfies readonly (keyof Opportunity)[];

/**
 * View-only fields that exist in database views but NOT on the Opportunity type
 * These are computed by SQL views and should be stripped before saving
 */
const VIEW_ONLY_FIELDS = [
  "search_tsv",
  "updated_by",
  "index",
  "total_value",
  "participant_count",
  "contact_count",
  "product_count",
  "last_activity_date",
] as const;

/**
 * Combined computed fields for stripping - includes both typed and view-only fields
 */
const COMPUTED_FIELDS = [
  ...TYPED_COMPUTED_FIELDS,
  ...VIEW_ONLY_FIELDS,
] as const;

/**
 * Virtual fields that should be stripped before database save
 * These are UI-only fields not present in the database schema
 *
 * NOTE: products_to_sync is NOT stripped here because:
 * 1. The handler layer (opportunitiesHandler.ts) needs to process it first
 * 2. Handler extracts products_to_sync and delegates to OpportunitiesService
 * 3. The service handles the atomic product sync and returns clean data
 * 4. By the time data reaches baseProvider.create/update, products_to_sync is already stripped
 */
const VIRTUAL_FIELDS = [
  "products", // Legacy field name, may come from some forms
] as const;

/**
 * Default values for opportunity create
 * Used to ensure validation passes when fields are missing
 */
const CREATE_DEFAULTS = {
  contact_ids: [] as number[],
} as const;

/**
 * Strip computed and virtual fields that shouldn't be sent to database
 *
 * @param data - The data being saved
 * @returns Data without computed/virtual fields
 */
function stripComputedFields(data: Partial<RaRecord>): Partial<RaRecord> {
  const cleaned = { ...data };

  // Strip computed fields (from views/aggregations)
  for (const field of COMPUTED_FIELDS) {
    delete cleaned[field];
  }

  // Strip virtual fields (UI-only, not in database schema)
  for (const field of VIRTUAL_FIELDS) {
    delete cleaned[field];
  }

  return cleaned;
}

/**
 * Merge default values for create operation
 * Ensures required fields have values for validation
 *
 * @param data - The data being created
 * @returns Data with defaults merged
 */
function mergeCreateDefaults(data: Partial<RaRecord>): Partial<RaRecord> {
  return {
    ...CREATE_DEFAULTS,
    ...data,
  };
}

// ============================================================================
// CUSTOM CALLBACKS (Override factory defaults)
// ============================================================================

/**
 * Custom beforeDelete: Use archive RPC for cascading soft delete
 *
 * WHY CUSTOM: Standard soft delete only sets `deleted_at` on ONE record.
 * Opportunities have related data that must be archived atomically:
 * - activities (calls, emails, meetings)
 * - opportunityNotes
 * - opportunity_participants (junction table)
 * - tasks
 *
 * The `archive_opportunity_with_relations` RPC handles this in a single transaction.
 */
async function opportunitiesBeforeDelete(
  params: DeleteParams,
  _dataProvider: DataProvider
): Promise<DeleteParams & { meta?: { skipDelete?: boolean } }> {
  // Validate ID before RPC call (fail-fast)
  const numericId = Number(params.id);
  if (!Number.isInteger(numericId) || numericId <= 0) {
    throw new Error(`Invalid opportunity ID: ${params.id}`);
  }

  // Use Supabase client directly - bypasses DataProvider abstraction
  // This is the React Admin recommended pattern for lifecycle callbacks
  const { error: rpcError } = await supabase.rpc("archive_opportunity_with_relations", {
    opp_id: numericId,
  });

  if (rpcError) {
    throw new Error(`Archive opportunity failed: ${rpcError.message}`);
  }

  // Return params with meta flag to skip actual delete (RPC already archived)
  return {
    ...params,
    meta: { ...params.meta, skipDelete: true },
  };
}

/**
 * Custom beforeGetList: Apply soft delete filter only
 *
 * NOTE: q filter transformation is handled centrally by applySearchParams() in composedDataProvider.
 * This callback only needs to apply the soft delete filter.
 */
async function opportunitiesBeforeGetList(
  params: GetListParams,
  _dataProvider: DataProvider
): Promise<GetListParams> {
  // Apply soft delete filter (search is handled by applySearchParams in composedDataProvider)
  const { includeDeleted, ...otherFilters } = params.filter || {};
  const softDeleteFilter = includeDeleted ? {} : { "deleted_at@is": null };

  return {
    ...params,
    filter: {
      ...otherFilters,
      ...softDeleteFilter,
    },
  };
}

/**
 * Custom beforeSave: Strip fields + handle stage-only updates
 *
 * WHY CUSTOM: Beyond standard computed field stripping, opportunities needs:
 * 1. Virtual field stripping (products_to_sync, products)
 * 2. Stage-only update detection for Kanban (strip empty contact_ids)
 * 3. Create defaults merging
 */
async function opportunitiesBeforeSave(
  data: Partial<RaRecord>,
  _dataProvider: DataProvider,
  _resource: string
): Promise<Partial<RaRecord>> {
  // Strip computed fields first
  let processed = stripComputedFields(data);

  // Strip empty contact_ids for stage-only updates (Kanban drag-drop)
  // NOTE: data.id is NOT available in beforeSave - id is passed separately as params.id
  // Detection: stage is present, name is NOT present (name is required for create/full edit)
  // When contact_ids is empty array from previousData merge, strip it to avoid validation error
  const isStageOnlyUpdate = data.stage && !data.name;
  const hasEmptyContactIds = Array.isArray(data.contact_ids) && data.contact_ids.length === 0;

  if (isStageOnlyUpdate && hasEmptyContactIds) {
    delete processed.contact_ids;
  }

  // Merge defaults for create (when no required fields present - indicates create operation)
  // Note: We check for name since it's required for create, not data.id (unavailable here)
  if (!data.name) {
    // Only merge defaults if this looks like a create (no id means create in validation layer)
    // But for stage-only updates, skip defaults
    if (!isStageOnlyUpdate) {
      processed = mergeCreateDefaults(processed);
    }
  }

  return processed;
}

// ============================================================================
// FACTORY + OVERRIDES (Hybrid Pattern)
// ============================================================================

/**
 * Base callbacks from factory
 * We DON'T use soft delete from factory because we need custom RPC cascade delete
 */
const baseCallbacks = createResourceCallbacks({
  resource: "opportunities",
  supportsSoftDelete: false, // We handle soft delete via custom RPC
  computedFields: [], // We handle in custom beforeSave (includes virtual fields)
  createDefaults: CREATE_DEFAULTS,
});

/**
 * Opportunities lifecycle callbacks for React Admin withLifecycleCallbacks
 *
 * Uses factory pattern with custom overrides for complex behaviors.
 * See module header comment for detailed explanation of WHY overrides are needed.
 *
 * Usage:
 * ```typescript
 * import { withLifecycleCallbacks } from 'react-admin';
 * import { opportunitiesCallbacks } from './callbacks/opportunitiesCallbacks';
 *
 * const dataProvider = withLifecycleCallbacks(baseProvider, [
 *   opportunitiesCallbacks,
 * ]);
 * ```
 */
export const opportunitiesCallbacks: ResourceCallbacks = {
  ...baseCallbacks,
  // Override with custom implementations
  beforeDelete: opportunitiesBeforeDelete,
  beforeGetList: opportunitiesBeforeGetList,
  beforeSave: opportunitiesBeforeSave,
  // afterRead is inherited from base (no-op since opportunities has no JSONB arrays)
};

/**
 * Export helper functions for testing
 */
export {
  stripComputedFields,
  mergeCreateDefaults,
  COMPUTED_FIELDS,
  TYPED_COMPUTED_FIELDS,
  VIEW_ONLY_FIELDS,
  CREATE_DEFAULTS,
};
