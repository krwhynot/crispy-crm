/**
 * Organizations Resource Lifecycle Callbacks
 *
 * Resource-specific logic for organizations using React Admin's withLifecycleCallbacks pattern.
 * Uses the createResourceCallbacks factory with custom cascade delete.
 *
 * Key behaviors:
 * 1. CASCADE SOFT DELETE - FIX [WF-C02]: Uses RPC to archive org AND related records
 * 2. Filter cleaning - Adds soft delete filter by default
 * 3. Data transformation - Strips computed fields before save
 * 4. Logo handling - Preserved by storage service
 * 5. Search transformation - Transforms q filter into ILIKE search on name, city, state, sector
 *
 * WHY CASCADE DELETE VIA RPC:
 * --------------------------
 * Standard soft delete only sets `deleted_at` on ONE record. Organizations have related data
 * that must be archived atomically:
 * - contacts → (and their activities, tasks, notes, participants, opportunity_contacts)
 * - opportunities → (and their activities, tasks, notes, products, participants)
 * - activities (directly linked to org)
 * - tasks (directly linked to org)
 * - organization_notes
 *
 * The `archive_organization_with_relations` RPC handles this in a single transaction,
 * recursively calling `archive_contact_with_relations` and `archive_opportunity_with_relations`.
 *
 * Engineering Constitution: Resource-specific logic extracted for single responsibility
 */

import type {
  RaRecord,
  GetListParams,
  DataProvider,
  DeleteParams,
  DeleteManyParams,
  CreateParams,
} from "ra-core";
import { createResourceCallbacks, type ResourceCallbacks } from "./createResourceCallbacks";
import { createQToIlikeTransformer } from "./commonTransforms";
import { supabase } from "../supabase";
import { collectOrganizationFilePaths, deleteStorageFiles } from "../utils/storageCleanup";
import { logger } from "@/lib/logger";

/**
 * Computed fields that should be stripped before saving to database
 * These are generated by the organizations_summary view or aggregations
 */
export const COMPUTED_FIELDS = [
  "contact_count",
  "opportunity_count",
  "total_revenue",
  "last_activity_date",
  "primary_contact_name",
  // From organizations_summary view (nb_* naming convention)
  "nb_contacts",
  "nb_opportunities",
  "nb_notes",
  // Hierarchy/parent fields
  "parent_organization_name",
  "child_branch_count",
  "total_contacts_across_branches",
  "total_opportunities_across_branches",
  "last_opportunity_activity",
  // PostgreSQL tsvector - auto-generated, cannot be updated
  "search_tsv",
] as const;

/**
 * Fields to search when q filter is provided
 * These fields will be searched with ILIKE for partial matching
 */
export const ORGANIZATIONS_SEARCH_FIELDS = ["name", "city", "state", "sector"] as const;

/**
 * Transform q filter into ILIKE search on organization fields
 * Uses raw PostgREST mode to handle multi-word searches correctly
 *
 * WORKAROUND for ra-data-postgrest library bug:
 * The library splits multi-word ILIKE values on whitespace and has a bug
 * handling 3+ words. Uses "or@" key with escaping to bypass this issue.
 *
 * @see createQToIlikeTransformer in commonTransforms.ts (useRawPostgrest mode)
 */
export const transformQToIlikeSearch = createQToIlikeTransformer({
  searchFields: ORGANIZATIONS_SEARCH_FIELDS,
  useRawPostgrest: true,
});

// ============================================================================
// CUSTOM CALLBACKS (Override factory defaults)
// ============================================================================

/**
 * Custom beforeDelete: Use archive RPC for cascading soft delete
 *
 * FIX [WF-C02]: Standard soft delete only sets `deleted_at` on ONE record.
 * Organizations have related data that must be archived atomically:
 * - contacts (recursively via archive_contact_with_relations)
 * - opportunities (recursively via archive_opportunity_with_relations)
 * - activities, tasks, organization_notes
 *
 * FIX [SF-C10]: Clean up storage files after archive.
 * Files in logo_url, organization_notes, and all child records are deleted.
 *
 * The `archive_organization_with_relations` RPC handles this in a single transaction.
 */
async function organizationsBeforeDelete(
  params: DeleteParams,
  _dataProvider: DataProvider
): Promise<DeleteParams & { meta?: { skipDelete?: boolean } }> {
  // Validate ID before RPC call (fail-fast)
  const numericId = Number(params.id);
  if (!Number.isInteger(numericId) || numericId <= 0) {
    throw new Error(`Invalid organization ID: ${params.id}`);
  }

  // FIX [SF-C10]: Collect file paths BEFORE archiving (records will be soft-deleted)
  // This includes: logo_url, organization_notes, contacts' files, opportunity_notes
  const filePaths = await collectOrganizationFilePaths(numericId);

  // Use Supabase client directly - bypasses DataProvider abstraction
  // This is the React Admin recommended pattern for lifecycle callbacks
  const { error: rpcError } = await supabase.rpc("archive_organization_with_relations", {
    org_id: numericId,
  });

  if (rpcError) {
    throw new Error(`Archive organization failed: ${rpcError.message}`);
  }

  // FIX [ERR-001]: Storage cleanup is intentionally fire-and-forget
  // Rationale: Archive operation already succeeded; storage cleanup failure
  // should not block user or cause rollback. Orphaned files are acceptable
  // technical debt that can be cleaned up via scheduled job.
  //
  // INTENTIONAL: Not awaited - cleanup runs in background
  if (filePaths.length > 0) {
    void deleteStorageFiles(filePaths).catch((err: unknown) => {
      // EH-002 FIX: Structured logging with context for debugging
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.warn(`Storage cleanup failed after organization archive`, {
        organizationId: params.id,
        fileCount: filePaths.length,
        files: filePaths.slice(0, 5), // First 5 for debugging, avoid huge logs
        error: errorMessage,
        operation: "organizationsBeforeDelete",
        note: "Archive succeeded - orphaned files can be cleaned up later",
      });
    });
  }

  // Return params with meta flag to skip actual delete (RPC already archived)
  return {
    ...params,
    meta: { ...params.meta, skipDelete: true },
  };
}

/**
 * Custom beforeDeleteMany: Use archive RPC for cascading soft delete of multiple orgs
 *
 * FIX [E2E-001]: Bulk delete from list view was bypassing cascade soft delete.
 * The `useDeleteMany` hook calls `dataProvider.deleteMany()`, not `delete()` multiple times.
 * Without this callback, bulk delete attempts a hard DELETE that violates FK constraints.
 *
 * This iterates through each organization ID and calls the archive RPC for atomic
 * cascade soft delete. Each call is independent - if one fails, others already
 * processed remain archived (acceptable for bulk operations).
 *
 * @param params - DeleteManyParams with `ids` array
 * @param _dataProvider - DataProvider (unused - we call RPC directly)
 * @returns Modified params with skipDelete flag to prevent actual deleteMany
 */
async function organizationsBeforeDeleteMany(
  params: DeleteManyParams,
  _dataProvider: DataProvider
): Promise<DeleteManyParams & { meta?: { skipDelete?: boolean } }> {
  // Archive each organization via RPC (atomic cascade soft delete per org)
  for (const id of params.ids) {
    const numericId = Number(id);
    if (!Number.isInteger(numericId) || numericId <= 0) {
      throw new Error(`Invalid organization ID: ${id}`);
    }

    // Collect file paths before archiving (same pattern as single delete)
    const filePaths = await collectOrganizationFilePaths(numericId);

    const { error: rpcError } = await supabase.rpc("archive_organization_with_relations", {
      org_id: numericId,
    });

    if (rpcError) {
      throw new Error(`Archive organization ${id} failed: ${rpcError.message}`);
    }

    // Fire-and-forget storage cleanup (same pattern as single delete)
    if (filePaths.length > 0) {
      void deleteStorageFiles(filePaths).catch((err: unknown) => {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logger.warn(`Storage cleanup failed after bulk organization archive`, {
          organizationId: id,
          fileCount: filePaths.length,
          files: filePaths.slice(0, 5),
          error: errorMessage,
          operation: "organizationsBeforeDeleteMany",
          note: "Archive succeeded - orphaned files can be cleaned up later",
        });
      });
    }
  }

  // Skip actual deleteMany - RPC already archived all records
  return {
    ...params,
    meta: { ...params.meta, skipDelete: true },
  };
}

/**
 * Base callbacks from factory (computed fields, transforms)
 * We DON'T use soft delete from factory because we need custom RPC cascade delete
 */
const baseCallbacks = createResourceCallbacks({
  resource: "organizations",
  supportsSoftDelete: false, // FIX [WF-C02]: We handle soft delete via custom RPC
  computedFields: COMPUTED_FIELDS,
});

/**
 * Custom beforeGetList that chains:
 * 1. q filter → ILIKE search transformation
 * 2. Soft delete filter (manual since we disabled factory soft delete)
 *
 * This matches the unified data provider's search behavior while applying
 * soft-delete filtering.
 */
async function organizationsBeforeGetList(
  params: GetListParams,
  _dataProvider: DataProvider
): Promise<GetListParams> {
  // Step 1: Transform q filter to ILIKE search (removes q from filter)
  const searchTransformedParams = transformQToIlikeSearch(params);

  // Step 2: Apply soft delete filter manually (since factory soft delete is disabled)
  const { includeDeleted, ...otherFilters } = searchTransformedParams.filter || {};
  const softDeleteFilter = includeDeleted ? {} : { "deleted_at@is": null };

  return {
    ...searchTransformedParams,
    filter: {
      ...otherFilters,
      ...softDeleteFilter,
    },
  };
}

/**
 * Organizations lifecycle callbacks for React Admin withLifecycleCallbacks
 *
 * FIX [WF-C02]: Uses custom beforeDelete that calls archive_organization_with_relations RPC
 * for atomic cascade soft delete of organization and all related records.
 *
 * Usage:
 * ```typescript
 * import { withLifecycleCallbacks } from 'react-admin';
 * import { organizationsCallbacks } from './callbacks/organizationsCallbacks';
 *
 * const dataProvider = withLifecycleCallbacks(baseProvider, [
 *   organizationsCallbacks,
 * ]);
 * ```
 */
export const organizationsCallbacks: ResourceCallbacks = {
  ...baseCallbacks,
  beforeDelete: organizationsBeforeDelete, // FIX [WF-C02]: Cascade via RPC (single)
  beforeDeleteMany: organizationsBeforeDeleteMany, // FIX [E2E-001]: Cascade via RPC (bulk)
  beforeGetList: organizationsBeforeGetList,
};

/**
 * Export stripComputedFields for backward compatibility with tests
 * The factory handles this internally, but tests may import it directly
 */
export function stripComputedFields(data: Partial<RaRecord>): Partial<RaRecord> {
  const cleaned = { ...data };
  for (const field of COMPUTED_FIELDS) {
    delete cleaned[field];
  }
  return cleaned;
}
