#!/bin/bash
# Pre-commit hook - Fast & Focused
# Only checks staged files, not entire codebase

# ANSI color codes
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FAST MODE: Skip slow checks while keeping security checks
# Usage: SKIP_SLOW_HOOKS=1 git commit -m "message"
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if [ "$SKIP_SLOW_HOOKS" = "1" ]; then
  echo -e "${YELLOW}âš¡ Fast mode: skipping type-check, discovery, and drift checks${NC}"
  SKIP_TYPECHECK=1
  SKIP_DISCOVERY=1
  SKIP_DRIFT=1
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. SECURITY: Block .env files (CRITICAL - always run)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
env_files=$(echo "$STAGED_FILES" | grep -E '\.env$|\.env\.' || true)

if [ -n "$env_files" ]; then
  echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${RED}âŒ COMMIT BLOCKED: .env file(s) detected${NC}"
  echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo
  echo -e "${YELLOW}The following .env files are staged for commit:${NC}"
  echo "$env_files" | sed 's/^/  - /'
  echo
  echo "To fix: git reset HEAD $env_files"
  echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  exit 1
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. UI PATTERNS: Enforce component standards (P1 - UI_STANDARDS.md)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tsx_feature_files=$(echo "$STAGED_FILES" | grep -E '^src/atomic-crm/.*\.tsx$' | grep -v -E '\.test\.|\.spec\.|__tests__' || true)

if [ -n "$tsx_feature_files" ]; then
  echo "ğŸ¨ Checking UI patterns..."
  ui_violations=0

  # Check for native <select> elements (use SelectInput from ra-wrappers)
  if echo "$tsx_feature_files" | xargs grep -l "<select" 2>/dev/null | grep -q .; then
    echo -e "${RED}âŒ Native <select> elements found in feature code${NC}"
    echo -e "${YELLOW}Use SelectInput from @/components/ra-wrappers instead${NC}"
    echo "$tsx_feature_files" | xargs grep -n "<select" 2>/dev/null | head -10
    ui_violations=1
  fi

  # Check for hardcoded border colors (use semantic: border-muted, border-destructive)
  if echo "$tsx_feature_files" | xargs grep -E 'border-(neutral|gray)-|border-\[#' 2>/dev/null | grep -q .; then
    echo -e "${RED}âŒ Hardcoded border colors found${NC}"
    echo -e "${YELLOW}Use semantic colors: border-muted, border-border, border-destructive${NC}"
    echo "$tsx_feature_files" | xargs grep -n -E 'border-(neutral|gray)-|border-\[#' 2>/dev/null | head -10
    ui_violations=1
  fi

  # Check for hardcoded background colors (use semantic: bg-muted, bg-background)
  if echo "$tsx_feature_files" | xargs grep -E 'bg-(neutral|gray)-' 2>/dev/null | grep -q .; then
    echo -e "${RED}âŒ Hardcoded background colors found${NC}"
    echo -e "${YELLOW}Use semantic colors: bg-muted, bg-background, bg-card${NC}"
    echo "$tsx_feature_files" | xargs grep -n -E 'bg-(neutral|gray)-' 2>/dev/null | head -10
    ui_violations=1
  fi

  if [ $ui_violations -eq 1 ]; then
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${RED}âŒ UI pattern violations detected. See UI_STANDARDS.md for guidance.${NC}"
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    exit 1
  fi

  echo -e "${GREEN}âœ“ UI patterns OK${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. QUICK CHECKS: TypeScript type-check (only if TS files staged)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ts_files=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx)$' || true)

if [ -n "$ts_files" ] && [ "$SKIP_TYPECHECK" != "1" ]; then
  echo "âš¡ Type-checking (incremental)..."
  if ! npx tsc --noEmit --incremental 2>/dev/null; then
    echo -e "${RED}âŒ TypeScript errors found. Run 'npx tsc --noEmit' for details.${NC}"
    exit 1
  fi
  echo -e "${GREEN}âœ“ Types OK${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 4. DISCOVERY: Fast hash-only staleness check (CI enforces full check)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Only run if component/hook files are staged (performance optimization)
discovery_files=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx)$' | grep -E 'src/atomic-crm/' || true)

if [ -n "$discovery_files" ] && [ "$SKIP_DISCOVERY" != "1" ]; then
  echo "ğŸ” Checking discovery freshness (hash-only)..."
  if ! npx tsx scripts/discover/check-staleness.ts 2>/dev/null; then
    echo -e "${YELLOW}âš  Discovery index may be stale. Run 'just discover' after commit.${NC}"
    # Don't auto-regenerate - let CI enforce freshness
  else
    echo -e "${GREEN}âœ“ Discovery files are fresh${NC}"
  fi
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 5. SEMANTIC COLORS: Prevent theme drift (P0 - 243 fix commits)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Only check staged TSX files for performance
tsx_files=$(echo "$STAGED_FILES" | grep -E '\.tsx$' || true)

if [ -n "$tsx_files" ]; then
  echo "ğŸ¨ Validating semantic colors..."
  if ! npm run validate:semantic-colors 2>/dev/null; then
    echo -e "${RED}âŒ Hardcoded colors detected. Run 'npm run validate:semantic-colors' for details.${NC}"
    echo -e "${YELLOW}Fix: Replace legacy Tailwind colors with semantic tokens (bg-warning, text-destructive, etc.)${NC}"
    exit 1
  fi
  echo -e "${GREEN}âœ“ Semantic colors OK${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 6. MIGRATIONS: Validate SQL migrations (P1 - 176 schema commits)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Only check staged SQL files in migrations directory
migration_files=$(echo "$STAGED_FILES" | grep -E '^supabase/migrations/.*\.sql$' || true)

if [ -n "$migration_files" ]; then
  echo "ğŸ—„ï¸ Validating migration files..."
  if [ -x "./scripts/validate-migrations.sh" ]; then
    if ! ./scripts/validate-migrations.sh --staged 2>/dev/null; then
      echo -e "${RED}âŒ Migration validation failed. Run './scripts/validate-migrations.sh' for details.${NC}"
      echo -e "${YELLOW}Fix: Check for missing columns, idempotent policies, and soft-delete patterns${NC}"
      exit 1
    fi
    echo -e "${GREEN}âœ“ Migrations OK${NC}"
  else
    echo -e "${YELLOW}âš  Migration validator not found, skipping...${NC}"
  fi
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 7. MIGRATION DRIFT: Detect local vs cloud schema divergence
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Only run when migration files are staged to catch drift early
# This prevents the scenario where local and cloud schemas diverge

if [ -n "$migration_files" ] && [ "$SKIP_DRIFT" != "1" ]; then
  echo "ğŸ”„ Checking migration drift (local vs cloud)..."

  # Check if supabase is linked (has .supabase directory or config)
  if [ -f "supabase/.temp/project-ref" ] || npx supabase projects list &>/dev/null; then

    # Run dry-run with 10-second timeout to detect drift
    # Skip gracefully if network is slow/unavailable
    if drift_output=$(timeout 10 npx supabase db push --dry-run 2>&1); then
      # Check for history mismatch (critical - cloud has migrations not in local)
      if echo "$drift_output" | grep -q "migration history does not match"; then
        echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${RED}âŒ MIGRATION DRIFT DETECTED${NC}"
        echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo
        echo -e "${YELLOW}Local and cloud migration histories have diverged.${NC}"
        echo -e "${YELLOW}This typically happens when migrations are applied directly to cloud.${NC}"
        echo
        echo "To investigate:"
        echo "  npx supabase db pull    # See what cloud has"
        echo "  npx supabase db push --dry-run  # See full diff"
        echo
        echo "To fix (after investigation):"
        echo "  npx supabase migration repair --status reverted <version>  # For cloud-only"
        echo "  npx supabase migration repair --status applied <version>   # For local-only"
        echo
        echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        exit 1
      fi

      # Check for pending migrations (warning only - local migrations not yet in cloud)
      if echo "$drift_output" | grep -qE "Would apply|migrations? to apply"; then
        echo -e "${YELLOW}âš  Pending migrations will be applied on next deploy${NC}"
      fi

      echo -e "${GREEN}âœ“ Migration sync OK${NC}"
    else
      echo -e "${YELLOW}âš  Migration drift check skipped (Supabase unavailable or timeout)${NC}"
    fi
  else
    echo -e "${YELLOW}âš  Supabase not linked, skipping drift check${NC}"
  fi
fi

# Full test suite: Run 'npm test' manually or rely on CI

echo -e "${GREEN}âœ“ Pre-commit checks passed${NC}"
